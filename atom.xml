<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://yuncheng1998.github.io</id>
    <title>Gridea</title>
    <updated>2021-04-11T14:30:34.152Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://yuncheng1998.github.io"/>
    <link rel="self" href="http://yuncheng1998.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://yuncheng1998.github.io/images/avatar.png</logo>
    <icon>http://yuncheng1998.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Clean Code]]></title>
        <id>http://yuncheng1998.github.io/post/clean-code/</id>
        <link href="http://yuncheng1998.github.io/post/clean-code/">
        </link>
        <updated>2021-04-11T14:29:15.000Z</updated>
        <content type="html"><![CDATA[<p>在一家公司实习，接手了一个权限相关的模块，正处一个新版本上线的时机，这个模块也是从其他模块中拆分出来的，上一任从老代码搬运过来并进行重构，后又由我接手来继续接受重构并进行新权限功能的开发。在重构期间开始读 <em>Robert C. Martin</em> 所著的 <em>代码整洁之道</em> 。在此期间对我起到了很大的指导作用。</p>
<h2 id="方法应该是什么样的">方法应该是什么样的</h2>
<h3 id="短小只做一件事">短小，只做一件事</h3>
<p>方法之所以写的冗长因为它做了太多的事情，一个好的方法应该短小清晰，过于长的代码是难以理解和维护的，因此应尽可能的将长方法进行拆分，首先要理解原方法的含义，然后将它所做的任务拆分成若干子任务，每个子任务进行以面向对象的思想进行封装。并且要规范的命名和写清楚 <em>javadoc</em> 注释。</p>
<h3 id="抽象层级">抽象层级</h3>
<p>这是一个容易被忽视的事情，并不是所有方法都在同一层级上。将方法按抽象层级进行区分并注意调用的位置，适合自顶向下的读代码习惯。</p>
<p>例如要从文件中获得字符串的List，现有一个读取文件的方法 <em>readFile</em> 和一个将字符串转换为字符数组 <em>convertString2List</em> 的方法。</p>
<ol>
<li>两个方法都在 <em>main</em> 中调用</li>
<li><em>main</em> 中调用 <em>readFile</em>，<em>readFile</em> 中调用 <em>convertString2List</em></li>
</ol>
<h3 id="不要返回-null">不要返回 <em>null</em></h3>
<p>低层级的方法尽量避免返回值为 <em>null</em> 的情况发生，来避免高层级代码需要进行的判空处理。应该及时在低层级代码判断null，如果为错误时抛出异常，或者返回空对象</p>
<h3 id="参数">参数</h3>
<p>对于诸如 <em>completeArg</em> 方法，使用 <em>Arg completeArg(Arg arg)</em> 通常要优于使用 <em>void completeArg(Arg arg)</em></p>
<p>对于参数中有 <em>Boolean</em> 类型的方法，若其在做两件不同的事情，应该将其拆分</p>
<p>对于有很多参数的方法，例如 <em>String generateSql(String tableName, String idName, String eiName, String authCondition, String ei)</em> 这样一个生成 <em>SQL</em> 语句的方法，前三个参数作为列名，完全可以用一个单独的类进行封装。若只在本类中调用，可以将其设置为私有类。然后使用对象作为参数<em>String generateSql(SqlArg sqlArg, String authCondition, String ei)</em></p>
<h3 id="无副作用">无副作用</h3>
<p>有些方法具有副作用在于当该方法被调用后，有一些调用者未预见的事情发生了。这主要是是由于命名不规范和违反了只做一件事原则而产生的</p>
<h3 id="不要有输出参数">不要有输出参数</h3>
<p>输出参数是面向过程所遗留下的产物，例如上面所提到的 <em>void completeArg(Arg arg)</em>，这类方法应该被改造为 <em>arg.completeArg()</em>，参数多数自然而染得被看作是输入，输入又输出的参数会给人造成迷惑</p>
<h3 id="分隔指令与询问">分隔指令与询问</h3>
<p>例如 <em>Java</em> 中的 <em>Set</em> 的 <em>add</em> 方法，会返回一个 <em>boolean</em> 类型表示插入是否成功，<em>contains</em> 用来判断集合中是否包含这个值。<em>add</em> 是指令、<em>contains</em> 是询问，应避免使用 <em>add</em> 来替代 <em>contains</em>。当然对于多线程应另行考虑。</p>
<h3 id="异常">异常</h3>
<p>除了模块提供的对外 <em>API</em> ，内部的方法应使用异常而不是错误码。调用的方法并判断返回值是错误码，这本身就违反了分隔指令与询问的原则。当使用 <em>try-catch</em> 去处理异常时，try代码块与catch代码块中分别做了两件不同的事，完全可以将其抽离出作为两个方法。另外对于 <em>try</em> 中有多行代码是容易给人造成混乱的，因为这样不知道异常是由哪些语句抛出的。良好的错误处理的<em>try-catch</em>语句必然是干净整洁的。</p>
<h3 id="结构化编程">结构化编程</h3>
<p><em>Dijkstra</em> 的结构化编程对于较长的方法是有重要作用的，保证这些方法只有一个出口、永远不会有goto语句，可以使这些方法的处理逻辑更加清晰。</p>
<h3 id="如何处理-switch">如何处理 <em>switch</em></h3>
<p>避免 <em>switch</em> 语句使代码违反单一权责原则和开闭原则的最好方法是使用工厂，将 <em>switch</em> 放到抽象工厂内部，用多态来接收返回值。</p>
<h2 id="对象与数据结构">对象与数据结构</h2>
<p>对象和数据结构应该作为两个不同的概念进行区分</p>
<ul>
<li>对象曝露行为，隐藏数据</li>
<li>数据结构曝露数据，没有明显行为</li>
</ul>
<p>通常所写的 <em>DTO</em>、<em>Bean</em> 都是数据结构，开放 <em>get</em>、<em>set</em> 方法可供调用。而 <em>Service</em> 的实现作为对象只去调用曝露的方法而不会关心内部的实现，对于对象我们应该仔细考虑哪些接口适合曝露出来。</p>
<p>对象和数据结构是一个对立的概念，数据结构更适合过程式代码，在不改动既有数据结构的前提下添加方法。而对象适合面向对象的代码，可以在不改动现有方法的情况下添加新的类。</p>
<p><em>The Law of Demeter</em> 是一个检验对象的使用是否标准的好方法。</p>
<blockquote>
<p>类C的的方法f只调用以下对象的方法</p>
<ul>
<li>C</li>
<li>f 创作的对象</li>
<li>作为参数传递给 f 的对象</li>
<li>C 的实体变量持有的对象</li>
</ul>
</blockquote>
<p>Redis 是使用 C语言编写的数据库，内部实现了多种数据结构：动态字符串、字典、压缩表、链表、跳跃表以及整数集合。但又基于数据结构实现了对象系统，每种对象可以根据需要选择不同的数据结构实现，数据结构应该考虑如何有效的存储数据。对象系统则提供交互方法，内部使用指针根据需要选用不同的数据结构。</p>
<h2 id="异常-2">异常</h2>
<h3 id="不可控异常">不可控异常</h3>
<p><em>Java</em> 区分可控异常和运行时异常，可控异常的使用需要在方法签名中对异常进行声明，使用可控异常的底层代码会使所有调用它的方法选择继续上抛还是处理。异常旨在可以在较远处处理错误，抛出的异常打破了代码的封装。例如我们自定义异常时，可以将其自 <em>RuntimeException</em> 类继承，在代码中抛出该异常，然后由 <em>Controller</em> 层一个统一的异常处理器对抛出的异常进行处理。</p>
<h3 id="好的异常捕获">好的异常捕获</h3>
<p>先写 <em>try-catch-finally</em> 语句，自上而下的编程方式容易梳理抽象逻辑，因此先写出异常捕获语句，将其分为三个语句块，这三个语句块分别在做不同的事情，因此可以考虑将其再拆分为方法。</p>
<p>如果一个方法抛出了多个异常，应该如何进行处理？在调用时使用 <em>try-catch</em> 对每个异常进行捕获是丑陋的做法，对于这样的情况，可以使用代理进行解决。为这个方法的对象建立一个代理，在代理类中对抛出多个异常的方法进行包装，在这个包装中进行记录日志等处理，统一抛出一个异常告诉调用者出现了异常。</p>
<p>抛出异常应提供足够的环境说明，而不是简单的只通过堆栈信息来追踪错误信息。使用日志系统来记录操作的初衷，和发生时参数等信息，这些信息被日志系统记录下来有利于错误信息的监控。</p>
<h3 id="特例模式">特例模式</h3>
<p>特例模式同样继承自普通类，但内部封装的是异常处理。诸如某些操作可能返回 <em>null</em>，而这可能作为一种特殊的情况考虑，就可以将其返回 <em>null</em> 的情况修改为返回特例类，有这个特殊对象来处理相应的逻辑，无论如何，null值是不应该被返回和传递的。</p>
<h2 id="类应该是什么样的">类应该是什么样的</h2>
<h3 id="自上而下的原则">自上而下的原则</h3>
<p>类从一组变量列表开始，顺序应为公共静态变量，私有静态变量，私有实体变量。</p>
<p>之后为公共方法，该公共方法调用的私有方法紧跟其后。</p>
<h3 id="单一权责">单一权责</h3>
<p>一个类只应该有一个权责，即只有一条修改的理由。如何判断类是否拥有了过多权责可以用以下方法：</p>
<ol>
<li>是否能明确的为该类命名</li>
<li>类中是否有过多实体变量</li>
</ol>
<p>好的类应该是足够内聚的，将过大的类拆分成内聚的小类，防止过分的耦合。</p>
<h3 id="开闭原则">开闭原则</h3>
<p>好的类要符合开闭原则，对于逻辑复杂的业务，合理的利用设计模式进行类的设计，使系统适应持续性的修改。因此类应该为了适合修改而组织（系统功能级别的修改），新增功能时尽可能少修改现有的类，而是通过扩展系统来添加新的特性。</p>
<h2 id="系统层级的整洁">系统层级的整洁</h2>
<p>系统层级是一个较高的抽象层级，这里主要关注功能实现的框架，而不是一些具体的编码规范。系统应该是整洁的，避免侵害性的架构。</p>
<h3 id="分离构造和使用">分离构造和使用</h3>
<p>分隔系统的构造和使用，让应用程序对构造过程一无所知，只是希望一切拿来即用。起始过程中构造对象会造成复杂的依赖关系，并且我们需要关系在每个环境中是否创建出了正确的对象，这又加大了单元测试的复杂程度，因此需要将构造与使用分开。对象的构造通常我们使用依赖注入或工厂来实现，工厂由应用程序决定何时创建对象，但细节却隔离于应用程序之外。依赖注入是 <em>Spring</em> 注入所提供的一个重要的功能，当我们需要某一对象时，只需要将其注入使用即可，构造过程由 <em>Spring</em> 来提供。</p>
<h3 id="切面">切面</h3>
<p><em>AOP</em> 使得增加新功能时不破坏原有的代码，避免了紧耦合问题。简单的情况下可以使用 Java 代理来实现一个功能在切面层级上的田间，但代理的复杂度和代码量让代码整洁变得很难，并且代理无法在系统范围内指定执行点，因此仍然需要 <em>AOP</em> 框架来实现。</p>
<h3 id="如何处理代码中大量的if-else待补充">如何处理代码中大量的if-else(待补充)</h3>
<ol>
<li>使用Map映射池</li>
<li>使用策略模式</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[跳跃表]]></title>
        <id>http://yuncheng1998.github.io/post/tiao-yue-biao/</id>
        <link href="http://yuncheng1998.github.io/post/tiao-yue-biao/">
        </link>
        <updated>2021-04-11T14:25:23.000Z</updated>
        <content type="html"><![CDATA[<p>最早在Redis设计与实现这本书中看到关于Redis中跳跃表的介绍，后来又在Java中使用跳表实现的ConcurrentSkipListMap，才发现这种数据结构有着广泛的应用。</p>
<h2 id="redis中的跳跃表">Redis中的跳跃表</h2>
<p>Redis中实现了skiplist这种有序的数据结构，以Redis的设计与实现中图示为例<br>
<img src="http://yuncheng1998.github.io/post-images/1618151152233.png" alt="Redis-skip-list" loading="lazy"><br>
这表示一个如下所示的跳跃表<br>
<img src="http://yuncheng1998.github.io/post-images/1618151184016.png" alt="redis-skip-list-2" loading="lazy"><br>
其中第一列为表头节点，有32层，但在此跳跃表中只有用到了5层，第一层是所有节点，每一个节点都有50%的概率会在上一层中包含，这样可以提高每个节点的访问速度，相当于为链表增加了二分查找的功能。这样即有着省去了链表需要从头到尾遍历的过程，也有着链表插入和删除很快的优点。<br>
下面是跳跃表的插入和删除的过程<br>
<img src="http://yuncheng1998.github.io/post-images/1618151211971.png" alt="skip-list-add-and-delete" loading="lazy"><br>
跳跃表相当于为链表增加了一层索引，先通过索引确定大概位置，然后在进行逐步的细化，是一种空间换时间的方式。<br>
Redis中的跳跃表是实现有序集合对象的一种数据结构，适应的Redis需要快速增删改查的需求。</p>
<h2 id="concurrentskiplistmap中的跳跃表">ConcurrentSkipListMap中的跳跃表</h2>
<p>ConcurrentSkipListMap的设计在有元素插入后，会进一步确定该元素是否需要建立索引，判断标准完全采用抛硬币的方式来实现</p>
<pre><code class="language-java">int rnd = ThreadLocalRandom.nextSecondarySeed();
    // 0x80000001展开为二进制为10000000000000000000000000000001
    // 只有两头是1
    // 这里(rnd &amp; 0x80000001) == 0
    // 相当于排除了负数（负数最高位是1），排除了奇数（奇数最低位是1）
    // 只有最高位最低位都不为1的数跟0x80000001做&amp;操作才会为0
    // 也就是正偶数
    if ((rnd &amp; 0x80000001) == 0) { // test highest and lowest bits
        // 默认level为1，也就是只要到这里了就会至少建立一层索引
        int level = 1, max;
        // 随机数从最低位的第二位开始，有几个连续的1则level就加几
        // 因为最低位肯定是0，正偶数嘛
        // 比如，1100110，level就加2
        while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)
            ++level;

        // 用于记录目标节点建立的最高的那层索引节点
        Index&lt;K,V&gt; idx = null;
        // 取头索引节点（这是最高层的头索引节点）
        HeadIndex&lt;K,V&gt; h = head;
        // 如果生成的层数小于等于当前最高层的层级
        // 也就是跳表的高度不会超过现有高度
        if (level &lt;= (max = h.level)) {
            // 从第一层开始建立一条竖直的索引链表
            // 这条链表使用down指针连接起来
            // 每个索引节点里面都存储着目标节点这个数据节点
            // 最后idx存储的是这条索引链表的最高层节点
            for (int i = 1; i &lt;= level; ++i)
                idx = new Index&lt;K,V&gt;(z, idx, null);
        }
        else { // try to grow by one level
            // 如果新的层数超过了现有跳表的高度
            // 则最多只增加一层
            // 比如现在只有一层索引，那下一次最多增加到两层索引，增加多了也没有意义
            level = max + 1; // hold in array and later pick the one to use
            // idxs用于存储目标节点建立的竖起索引的所有索引节点
            // 其实这里直接使用idx这个最高节点也是可以完成的
            // 只是用一个数组存储所有节点要方便一些
            // 注意，这里数组0号位是没有使用的
            @SuppressWarnings(&quot;unchecked&quot;)Index&lt;K,V&gt;[] idxs =
                    (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[level+1];
            // 从第一层开始建立一条竖的索引链表（跟上面一样，只是这里顺便把索引节点放到数组里面了）
            for (int i = 1; i &lt;= level; ++i)
                idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null);

            // 自旋
            for (;;) {
                // 旧的最高层头索引节点
                h = head;
                // 旧的最高层级
                int oldLevel = h.level;
                // 再次检查，如果旧的最高层级已经不比新层级矮了
                // 说明有其它线程先一步修改了值，从头来过
                if (level &lt;= oldLevel) // lost race to add level
                    break;
                // 新的最高层头索引节点
                HeadIndex&lt;K,V&gt; newh = h;
                // 头节点指向的数据节点
                Node&lt;K,V&gt; oldbase = h.node;
                // 超出的部分建立新的头索引节点
                for (int j = oldLevel+1; j &lt;= level; ++j)
                    newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);
                // 原子更新头索引节点
                if (casHead(h, newh)) {
                    // h指向新的最高层头索引节点
                    h = newh;
                    // 把level赋值为旧的最高层级的
                    // idx指向的不是最高的索引节点了
                    // 而是与旧最高层平齐的索引节点
                    idx = idxs[level = oldLevel];
                    break;
                }
            }
        }
</code></pre>
<h2 id="为什么不选择树">为什么不选择树</h2>
<p>跳表插入元素、删除元素、查找元素的时间复杂度与平衡二叉树相同为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msubsup><mi>g</mi><mn>2</mn><mi>n</mi></msubsup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log_2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，输出区间内元素的复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。而红黑树对输出区间内元素的支持性较差，每次需要从首位置来查找。与B+树比较来看，B+树提供了指向了下一个元素的指针，可以方便的获得区间内元素，增删改查的时间复杂度与跳跃表相同，但跳跃表的实现较B+树更为简单。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[增强try-catch]]></title>
        <id>http://yuncheng1998.github.io/post/try-catch/</id>
        <link href="http://yuncheng1998.github.io/post/try-catch/">
        </link>
        <updated>2019-07-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>在传统的 <code>try-catch-finally</code> 语句中，需要将一些必须执行的步骤放在 <em>finally</em> 语句块中，诸如关闭资源，释放连接等。例如下面代码是将对象序列化到文件中后再反序列化读取出来的步骤，在 <em>finally</em> 语句块中，要判断两个文件流是否成功创建，然后再执行关闭操作，这样造成了代码的啰嗦。</p>
<pre><code class="language-java">public class App {
    private static final String PATH = &quot;/Users/yuncheng/IdeaProjects/leetcode-log/src/main/java/top/wangych/file.in&quot;;
    public static void main(String[] args) {
        ObjectInputStream objectInputStream = null;
        ObjectOutputStream objectOutputStream = null;
        try {
            objectOutputStream = new ObjectOutputStream(new FileOutputStream(PATH));
            objectInputStream= new ObjectInputStream(new FileInputStream(PATH));
            Student student = new Student();
            student.setName(&quot;test&quot;);
            objectOutputStream.writeObject(student);
            student = (Student) objectInputStream.readObject();
            System.out.println(student.getName());

        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            if (objectInputStream != null) {
                try {
                    objectInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (objectOutputStream != null) {
                try {
                    objectOutputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

@Data
class Student implements Serializable {

    private static final long serialVersionUID = -8955603390013362711L;
    private String name;
}
</code></pre>
<p>在Java7中提供了增强try语句来释放资源，如下所示</p>
<pre><code class="language-java">public class App {
    private static final String PATH = &quot;/Users/yuncheng/IdeaProjects/leetcode-log/src/main/java/top/wangych/file.in&quot;;
    public static void main(String[] args) {
        try (
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(PATH));
          ObjectInputStream objectInputStream= new ObjectInputStream(new FileInputStream(PATH))
        ) {

            Student student = new Student();
            student.setName(&quot;test&quot;);
            objectOutputStream.writeObject(student);
            student = (Student) objectInputStream.readObject();
            System.out.println(student.getName());

        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>增强try语句是一种语法糖，查看编译后的的代码如下，仍然生成finally语句块来释放资源。释放的方式是调用括号内对象的close()方法，这就要求该类必须实现了 <em>Closeable</em> 接口。<br>
<img src="http://www.wangych.top/upload/2019/7/%E5%A2%9E%E5%BC%BAtry-27866803a9f846d39d87ae63a6e21457.png" alt="增强try" loading="lazy"></p>
<p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/language/try-with-resources.html">The try-with-resources Statement</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[蓄水池采样、Rand7和洗牌算法]]></title>
        <id>http://yuncheng1998.github.io/post/about/</id>
        <link href="http://yuncheng1998.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h3 id="蓄水池采样">蓄水池采样</h3>
<p>给定一个无限的数据流，要求随机取出 k 个数。也就是说当数据流有 N 个数据时，不论 N 为多少，每个数被取出的概率都为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">k/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></p>
<p><strong>采样方法</strong><br>
先取出先 k 个数，从 k+1 个数开始以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">k/i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord mathdefault">i</span></span></span></span> 的概率取出这个数，随机替换掉k个数中的一个数。</p>
<p><strong>证明</strong><br>
使用数学归纳法进行证明</p>
<ol>
<li>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个数被取出的概率为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">k/(k+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，前k个数中每个数被取出的概率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">1/k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，则每个数被保留的概率为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>−</mo><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>k</mi><mo>)</mo><mo>∗</mo><mo>(</mo><mi>k</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>=</mo><mi>k</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">1-(1/k) * (k/(k+1)) = k/(k+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，与第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个数被取出的概率相同，每个数字保留的概率均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">k/(k+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">i=p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>时符合条件，则前p个数保留的概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">k/p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord mathdefault">p</span></span></span></span>，证明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>p</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=p+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时保留的概率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">k/(p+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<ol>
<li>p+1个数被取出的概率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">k/(p+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>前p个数保留下来个概率为：<strong>在p个数中被选中的概率 * 没有被第p+1个数替换的概率</strong>。即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>k</mi><mi mathvariant="normal">/</mi><mi>p</mi><mo>)</mo><mo>∗</mo><mo>(</mo><mn>1</mn><mo>−</mo><mo>(</mo><mi>k</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>∗</mo><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>k</mi><mo>)</mo><mo>)</mo><mo>=</mo><mi>k</mi><mi mathvariant="normal">/</mi><mo>(</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(k/p) * (1-(k/(p+1)) * (1/k)) = k/(p+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ol>
<p>证明得出p+1时成立。</p>
</li>
</ol>
<p>例如给定一个不定长的单向链表，实现一个 <em>getRandomNode(ListNode head)</em> 方法从链表中随机获得一个节点，要求每个节点被选中的概率相等且只能遍历一次链表<br>
<strong>代码实现</strong></p>
<pre><code class="language-java">public ListNode getRandomNode(ListNode head) {
    ListNode ans = head;
    ListNode node = head.next;
    int i = 2;
    Random random = new Random();
    while (ans != null) {
        // 节点被选中的概率为1/i
        int ran = random.nextInt(i);
        // 节点被选中
        if (ran == 0) {
            ans = node;
        }
        node = node.next;
        i++;
    }
    return ans;
}
</code></pre>
<h3 id="rand7">Rand7</h3>
<p>假设有一个 <em>rand7()</em> 方法，要求使用它实现 <em>rand5()</em> 方法，只需要调用 <em>rand7</em> ，只选取其位于 [0,4] 之间的数，否则继续调用即可。这就意味着使用 <em>randN()</em> 实现 <em>randM()</em> 时，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>&gt;</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">N&gt;M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>，都可以使用该方法。但如果是使用 <em>rand5()</em> 来实现 <em>rand7()</em> 呢？</p>
<p>考虑数值的进制表示，使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mn>5</mn><mo>(</mo><mo>)</mo><mo>∗</mo><mn>5</mn><mo>+</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mn>5</mn><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">rand5() * 5 + rand5()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">5</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">5</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 可以生成从0到24的数字，这些数字是随机分布的。可以将其看作随机生成了一组5进制数字，其对应10进制也必然是随机的。即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>N</mi><mo>(</mo><mo>)</mo><mo>∗</mo><mi>N</mi><mo>+</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>N</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">randN() * N + randN()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 会产生 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N * N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 个均匀分布的数字</p>
<p>另外由于产生25个数字只截取前7个太过浪费，因此可以将7在25的范围内映射3次，即截取前21个数字 [0,20]，将选取的数字对7取模即可。</p>
<p><strong>代码实现</strong></p>
<pre><code class="language-java">public static int rand7() {
  int n = rand5() * 5 + rand5();
    if (n &lt; 21) {
      return n % 7;
    }
  return rand7();
}
</code></pre>
<h3 id="洗牌算法">洗牌算法</h3>
<p>给定一个数组进行随机打乱。根据 <em>The Art of Computer Programming</em> 中的算法为：遍历数组，每次将一个元素与它本身及以后随机一个元素交换位置即可。</p>
<p><strong>证明</strong><br>
要证明每张牌出现在每个位置上的概率都想等，只需要证明每个位置上出现每张牌的概率相等，都为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 即可。第一个位置上出现牌k的概率为1/N，第二个位置出现的概率为<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mi>N</mi><mo>)</mo><mo>∗</mo><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mo>(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">((N-1)/N) * (1/(N-1))=1/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><br>
同理第i个位置上出现牌K的概率为：<strong>牌K在i到N的位置上的概率 * 选中该位置的概率</strong><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mo>(</mo><mi>N</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mi>N</mi><mo>)</mo><mo>∗</mo><mo>(</mo><mn>1</mn><mi mathvariant="normal">/</mi><mo>(</mo><mi>N</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">((N-i+1)/N) * (1/(N-i+1)) = 1/N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></p>
<p><strong>代码实现</strong></p>
<pre><code class="language-java">public static void shuffle(int[] nums) {
    Random random = new Random();
    for (int i = 0; i &lt; nums.length; i++) {
      int position = random.nextInt(nums.length - i) + i;
      int temp = nums[i];
      nums[i] = nums[position];
      nums[position] = temp;
    }
    System.out.println(Arrays.toString(nums));
}
</code></pre>
]]></content>
    </entry>
</feed>
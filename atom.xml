<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yuncheng1998.github.io</id>
    <title>云程的BLOG</title>
    <updated>2021-04-27T05:45:59.254Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yuncheng1998.github.io"/>
    <link rel="self" href="https://yuncheng1998.github.io/atom.xml"/>
    <subtitle>潜龙勿用</subtitle>
    <logo>https://yuncheng1998.github.io/images/avatar.png</logo>
    <icon>https://yuncheng1998.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 云程的BLOG</rights>
    <entry>
        <title type="html"><![CDATA[朋友圈问题]]></title>
        <id>https://yuncheng1998.github.io/post/mArWjG4B0/</id>
        <link href="https://yuncheng1998.github.io/post/mArWjG4B0/">
        </link>
        <updated>2021-04-17T09:56:23.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/number-of-provinces/comments/">省份数量</a></p>
<h1 id="dfsbfs搜索">DFS/BFS搜索</h1>
<p>使用一个<strong>标记数组</strong>，依次判断每个节点，如果其未访问：朋友圈数+1并对该节点进行DFS/BFS标记所有访问到的节点。</p>
<pre><code class="language-java">class Solution {
      public int findCircleNum(int[][] isConnected) {
    int ans = 0;
    boolean[] flag = new boolean[isConnected.length];
    for (int i = 0; i &lt; flag.length; i++) {
      // 没有被访问
      if (!flag[i]) {
        ans++;
        flag[i] = true;
        dfs(isConnected, flag, i);
      }
    }
    System.out.println(ans);
    return ans;
  }

  /**
   * 以i为中心开始深度优先遍历
   */
  private void dfs(int[][] isConnected, boolean[] flag, int i) {
    for (int j = 0; j &lt; flag.length; j++) {
      if (isConnected[i][j] == 1) {
        if (!flag[j]) {
          flag[i] = true;
          dfs(isConnected, flag, j);
        }
      }
    }
  }
}
</code></pre>
<h1 id="查并集">查并集</h1>
<pre><code class="language-java">class Solution {
    int[] cities;
    public void union(int i, int j) {
        cities[i] = j;
    }
    public int find(int i) {
        if (cities[i] == -1) {
        return i;
        } else {
        int p = cities[i];
        while (cities[p] != -1) {
            p = cities[p];
        }
        return p;
        }
    }
    public int findCircleNum(int[][] isConnected) {
    cities = new int[isConnected.length];
    // 初始化
    Arrays.fill(cities, -1);
    for (int i = 0; i &lt; isConnected.length; i++) {
      for (int j = i + 1; j &lt; isConnected.length; j++) {
        if (isConnected[i][j] == 1) {
          int ip = find(i);
          int jp = find(j);
          if (ip != jp) {
            union(ip, j);
          }
        }
      }
    }
    return (int)Arrays.stream(cities).filter(x -&gt; x == -1).count();
  }
}
</code></pre>
<h2 id="查并集的优化方法">查并集的优化方法</h2>
<p>降低树的高度：将树上每个节点都指向根节点</p>
<pre><code class="language-java">public int find(int i) {
    if (cities[i] == -1) {
      return i;
    } else {
      int parent = cities[i];
      while (cities[parent] != -1) {
        parent = cities[parent];
      }
      // 将[i,p)都指向parent
      while (cities[i] != -1) {
        int tmp = cities[i];
        cities[cities[tmp]] = parent;
        i = tmp;
      }
      return parent;
    }
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[复用类]]></title>
        <id>https://yuncheng1998.github.io/post/Qe7mvB1pJ/</id>
        <link href="https://yuncheng1998.github.io/post/Qe7mvB1pJ/">
        </link>
        <updated>2021-04-12T05:35:36.000Z</updated>
        <content type="html"><![CDATA[<p>复用代码是 <em>Java</em> 众多引人注目的功能之一，如何实现对已有类更加灵巧的复用是程序设计中需要考虑的重要问题。本文是在研读 <em>Thinking in Java</em> 复用类一章后的思考与总结。</p>
<h4 id="复用的方法">复用的方法</h4>
<p>要使用现有类而不破坏现有代码主要有两种方式，组合与继承。前者直接在新的类中产生现有类的对象，后者则是在现有类的形式中添加代码。二者均是利用现有类型产生新类型，均在新类中包含了现有类的引用，对于组合这种引用是显式的，而对于继承则是隐式的。</p>
<h4 id="组合">组合</h4>
<p>在新类中显式地产生现有类的对象，新类是由现有类组合而成的。现有类的对象默认初始化为 <em>null</em>，若我们需要进行初始化，有以下四种方式</p>
<ol>
<li>
<p>在定义对象的地方</p>
</li>
<li>
<p>在类的构造器中</p>
</li>
<li>
<p>使用对象前进行惰性初始化</p>
<p>当不必要每次都生成对象时，使用惰性初始化可以减少负担</p>
</li>
<li>
<p>使用实例初始化</p>
<p>实例初始化是在类内部的一个代码块，在创建对象时执行，为该类的实例对象赋值</p>
</li>
</ol>
<h4 id="继承">继承</h4>
<p>使用 <em>extends</em> 关键字实现类的继承，子类会自动得到超类中可以继承的所有的域和方法。可以认为在子类中包含了一个超类的引用 <em>super</em>，在子类中可以通过 <em>super</em> 关键字可以使用超类。</p>
<p>要明确的是，在继承中 <em>JVM</em> 先加载超类，然后加载子类。创建子类对象时，会在子类对象的构造器中默认调用超类的无参构造器 <em>super()</em>（若要使用有参构造器则必须进行覆盖）。这个超类对象以 <em>super</em> 关键字来指代。<br>
<img src="https://yuncheng1998.github.io/post-images/1618205840756.png" alt="超类子类" loading="lazy"><br>
一个有继承关系的子类如上图所示，其中包括了子类特有的方法，子类重写超类中的方法和超类中提供的调用接口。超类中提供的接口会自动被子类继承，若要在子类中调用现有类的方法需要使用 <em>super</em> 进行指代。</p>
<h4 id="代理">代理</h4>
<p>代理是一种复用类的设计模式，是继承与组合的中庸之道，<em>Java</em> 中并没有直接提供对代理的支持。代理的思想是建立一个包含了现有对象（目标对象）的代理对象，在代理对象中对目标对象进行包装和扩展。即对目标类加一层包装，对于目标对象的方法进行选择性的提供，这样就可以让用户调用代理对象来避免其使用目标对象中不希望暴露给使用者的方法。<br>
<img src="https://yuncheng1998.github.io/post-images/1618205799288.png" alt="复用类" loading="lazy"></p>
<h4 id="组合与继承的选择">组合与继承的选择</h4>
<p>组合与继承是实现复用类功能的两个主要方式，我们常听说设计模式中强调少用继承来降低程序的耦合性，因此在选择组合与继承时常常偏向于组合。但我们需要理解组合与继承的设计思想，才能做出更好的选择。</p>
<ul>
<li>
<p>组合的意义在于使用现有类的功能能让新类产生新的功能，新类的用户只能看到新类定义的接口。</p>
</li>
<li>
<p>继承的意义在于使用一个通用类，为了需要可以将其特殊化，新类与现有类是 <em>is-a</em> 关系。</p>
</li>
</ul>
<p>另外，如果必须实现向上转型，那么继承是必要的</p>
<h4 id="总结">总结</h4>
<p>继承和组合都能从现有类型中产生新的类型，组合将现有类型作为新类型底层实现的一部分加以复用，而继承复用的是接口。对于继承、组合或代理的选择需要综合程序耦合性、灵活性、是否需要多态机制等多方面考虑，需要理解这几种方式的设计思想才能做出更好的选择。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重读深入理解Java虚拟机（三）—— 读深入理解JVM之类文件结构]]></title>
        <id>https://yuncheng1998.github.io/post/gzTjEwfjN/</id>
        <link href="https://yuncheng1998.github.io/post/gzTjEwfjN/">
        </link>
        <updated>2021-04-12T05:28:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="类文件结构">类文件结构</h1>
<p>最近在读 <a href="https://book.douban.com/subject/24722612/"><em>深入理解 Java虚拟机</em></a>，这里列出类文件结构部分大纲，还需配合该书进行学习。</p>
<h3 id="无关性">无关性</h3>
<ul>
<li>字节码存储格式
<ul>
<li>虚拟机只与字节码文件进行绑定</li>
<li>安全性：对字节码文件有很多强制性约束</li>
</ul>
</li>
<li>虚拟机
<ul>
<li>虚拟机只执行字节码文件，而不关心它的来源</li>
<li>字节码文件描述能力比Java语言更强大</li>
</ul>
</li>
</ul>
<h3 id="class类文件的结构">Class类文件的结构</h3>
<h4 id="注意">注意</h4>
<ul>
<li>每一个Class文件都对应唯一的类或接口，但这个类或接口不一定在文件中，可以通过类加载器直接生成</li>
<li>以8字节为基础单位的二进制流
<ul>
<li>占用8位以上空间的数据项需要分割
<ul>
<li>分割方式：高位在前</li>
</ul>
</li>
</ul>
</li>
<li>使用伪结构来存储数据</li>
</ul>
<h4 id="两种数据类型">两种数据类型</h4>
<ul>
<li>无符号数
<ul>
<li>基本数据类型</li>
<li>分类
<ul>
<li>u1</li>
<li>u2</li>
<li>u4</li>
<li>u8</li>
</ul>
</li>
</ul>
</li>
<li>表
<ul>
<li>复合数据类型
<ul>
<li>有层次</li>
</ul>
</li>
<li>由多个无符号数组成</li>
</ul>
</li>
</ul>
<h4 id="集合">集合</h4>
<ul>
<li>有同一类型但数量不定的多个数据时
<ul>
<li>前置容量计数器</li>
</ul>
</li>
</ul>
<h4 id="文件格式">文件格式</h4>
<ul>
<li>magic
<ul>
<li>魔数：CAFE BABE</li>
<li>标识文件类型</li>
<li>u4</li>
</ul>
</li>
<li>版本
<ul>
<li>minor_version
<ul>
<li>Class文件的次版本号</li>
<li>u2</li>
</ul>
</li>
<li>major_version
<ul>
<li>Class文件主版本号</li>
<li>u2</li>
</ul>
</li>
</ul>
</li>
<li>常量集合
<ul>
<li>constant_pool_count
<ul>
<li>常量池中常量个数计数</li>
<li>u2</li>
</ul>
</li>
<li>constant_pool
<ul>
<li>常量池</li>
<li>长度为constant_pool_count - 1
<ul>
<li>第0号常量池表示指向常量池的索引值数据表达不引用任何一个常量池项目</li>
</ul>
</li>
<li>常量池的两大类常量
<ul>
<li>字面量
<ul>
<li>字符串，声明为final的常量值</li>
<li>运行期不发生动态链接</li>
</ul>
</li>
<li>符号引用
<ul>
<li>包含的三类常量
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li>符号引用在运行期间经过转换得到真正的内存入口地址</li>
</ul>
</li>
</ul>
</li>
<li>常量池中的常量
<ul>
<li>每个常量都是表结构
<ul>
<li>表结构第一项都是tag，表示常量的类型</li>
</ul>
</li>
<li>14中常量有自己的表结构
<ul>
<li>即有不同的表示</li>
</ul>
</li>
<li>在字段表、方法表、属性表中存在对这些常量的引用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>access_flags
<ul>
<li>访问标志</li>
<li>标识
<ul>
<li>是否public</li>
<li>是否final</li>
<li>是否允许使用invokespecial字节码指令的新语意
<ul>
<li>JDK 1.0.2后都为真</li>
<li>改指令语意发生过改变</li>
</ul>
</li>
<li>是否是接口</li>
<li>是否是abstract</li>
<li>标识该类不是由用户代码产生</li>
<li>标识是注解</li>
<li>标识是枚举</li>
</ul>
</li>
<li>u2</li>
</ul>
</li>
<li>this_class
<ul>
<li>类索引</li>
<li>u2</li>
</ul>
</li>
<li>super_class
<ul>
<li>父类索引</li>
<li>u2</li>
</ul>
</li>
<li>接口索引集合
<ul>
<li>interfaces_count
<ul>
<li>接口索引计数</li>
<li>u2</li>
</ul>
</li>
<li>interfaces
<ul>
<li>接口索引集合</li>
</ul>
</li>
</ul>
</li>
<li>字段表集合
<ul>
<li>fields_count
<ul>
<li>字段表集合中字段的个数</li>
<li>u2</li>
</ul>
</li>
<li>fields
<ul>
<li>字段表集合
<ul>
<li>字段是接口或类中声明的变量</li>
<li>在Class文件中字段以字段表的形式存储</li>
<li>除属性表集合外其他均为u2类型</li>
</ul>
</li>
<li>字段包含的信息
<ul>
<li>作用域</li>
<li>实例变量还是类变量</li>
<li>可变性</li>
<li>并发可见性</li>
<li>可否序列化</li>
<li>字段数据类型</li>
<li>字段名称</li>
</ul>
</li>
<li>字段表结构
<ul>
<li>access_flag
<ul>
<li>访问类型</li>
</ul>
</li>
<li>name_index
<ul>
<li>字段名称</li>
<li>指向常量池</li>
</ul>
</li>
<li>descrptor_index
<ul>
<li>方法描述</li>
<li>指向常量池</li>
</ul>
</li>
<li>attribute_count</li>
<li>attributes</li>
</ul>
</li>
<li>描述符规则
<ul>
<li>基本数据类型使用大写字母表示</li>
<li>对象类型使用L加对象全限定名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>方法表集合
<ul>
<li>methods_count
<ul>
<li>方法集合的计数</li>
<li>u2</li>
</ul>
</li>
<li>methods
<ul>
<li>方法表集合
<ul>
<li>方法在Class文件中以方法表的形式存储</li>
</ul>
</li>
<li>方法表结构
<ul>
<li>access_flag</li>
<li>name_index
<ul>
<li>指向常量池</li>
<li>常量池中存方法名</li>
</ul>
</li>
<li>descriptor_index
<ul>
<li>(方法参数)返回值类型</li>
</ul>
</li>
<li>attribute_count</li>
<li>attributes
<ul>
<li>Code属性存放了方法体字节码指令</li>
</ul>
</li>
</ul>
</li>
<li>注意
<ul>
<li>若没有重写，不会出现父类方法信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>属性表集合
<ul>
<li>attributes_count</li>
<li>attributes
<ul>
<li>属性表结构
<ul>
<li>attribute_name_index
<ul>
<li>u2</li>
<li>指向常量池来获取名称</li>
</ul>
</li>
<li>attribute_length
<ul>
<li>u4</li>
<li>使用该字段指定长度</li>
<li>以字节为单位</li>
</ul>
</li>
<li>info
<ul>
<li>u1</li>
<li>数量为attribute_length定义的数量</li>
<li>属性结构完全自定义</li>
</ul>
</li>
</ul>
</li>
<li>预定义的属性
<ul>
<li>Code
<ul>
<li>Code属性表的结构
<ul>
<li>attribute_name_index</li>
<li>attribute_length</li>
<li>max_stack
<ul>
<li>操作数栈最大深度</li>
<li>用来分配栈帧中操作数栈深度</li>
</ul>
</li>
<li>max_locals
<ul>
<li>局部变量表所需的存储空间</li>
<li>单位slot</li>
<li>并不是所有变量所占slot的和
<ul>
<li>注意slot可以重用，当代码执行超过该局部变量范围时，slot可以重新赋值</li>
</ul>
</li>
</ul>
</li>
<li>code_length
<ul>
<li>Java源程序编译后的字节码指令长度</li>
<li>u4类型</li>
<li>但只能使用u2的长度</li>
</ul>
</li>
<li>code
<ul>
<li>存储字节码指令一系列字节流
<ul>
<li>每个指令都是u1的单字节</li>
</ul>
</li>
</ul>
</li>
<li>异常表集合
<ul>
<li>不是必须存在</li>
<li>异常表结构
<ul>
<li>start_pc
<ul>
<li>开始行
<ul>
<li>字节码相对于方法体的偏移量</li>
</ul>
</li>
</ul>
</li>
<li>end_pc
<ul>
<li>结束行</li>
</ul>
</li>
<li>handler_pc
<ul>
<li>出现异常跳转行</li>
</ul>
</li>
<li>catch_type
<ul>
<li>异常类型
<ul>
<li>指向一个CONSTANT_Class_info型常量的索引</li>
<li>当该值为0时，表示任意异常都要转到handler_pc进行处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>使用异常表而不是跳转来完成异常处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Exceptions属性
<ul>
<li>列举方法中可能抛出的受检查的异常
<ul>
<li>throws关键字后的异常</li>
</ul>
</li>
<li>属性表结构
<ul>
<li>attribute_name_index</li>
<li>attribute_length</li>
<li>number_of_exceptions
<ul>
<li>抛出受检查异常的种类数</li>
</ul>
</li>
<li>exception_index_table
<ul>
<li>指向常量池中CONSTANT_Class_info型常量的索引
<ul>
<li>代表受查异常的类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>LineNumberTable属性
<ul>
<li>Java源码行号与字节码行号的对应关系
<ul>
<li>行号：偏移量</li>
</ul>
</li>
<li>属性结构
<ul>
<li>attribute_name_index
<ul>
<li>属性名</li>
</ul>
</li>
<li>attribute_length
<ul>
<li>属性长度</li>
</ul>
</li>
<li>line_number_table_length
<ul>
<li>映射表长度</li>
</ul>
</li>
<li>line_number_table
<ul>
<li>集合
<ul>
<li>大小：line_number_table_length</li>
<li>类型：line_number_info
<ul>
<li>line_number_info包括start_pc和line_number两个u2类型的数据项</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>LocalVariableTable属性
<ul>
<li>栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系
<ul>
<li>缺失时IDE会使用args0等占位符来代替</li>
</ul>
</li>
<li>属性结构
<ul>
<li>attribute_name_index
<ul>
<li>属性名</li>
<li>指向常量池</li>
</ul>
</li>
<li>attribute_length
<ul>
<li>属性长度</li>
</ul>
</li>
<li>local_variable_table_length
<ul>
<li>映射表表长</li>
</ul>
</li>
<li>local_variable_table
<ul>
<li>大小：local_variable_table_length指定</li>
<li>类型：local_variable_info
<ul>
<li>结构
<ul>
<li>start_pc
<ul>
<li>局部变量生命周期开始的字节码偏移量</li>
</ul>
</li>
<li>length
<ul>
<li>局部变量作用范围覆盖的长度</li>
</ul>
</li>
<li>name_index
<ul>
<li>局部变量的名称</li>
<li>指向常量池</li>
</ul>
</li>
<li>descriptor_index
<ul>
<li>局部变量的描述符</li>
<li>指向常量池</li>
</ul>
</li>
<li>index
<ul>
<li>局部变量在栈帧局部变量表中Slot的位置</li>
<li>若为64位类型时，占用index和index+1两个位置</li>
</ul>
</li>
</ul>
</li>
<li>与LocalVariableTypeTable的区分
<ul>
<li>描述泛型</li>
<li>描述符中泛型的参数化类型被擦除，描述符不能准确描述泛型类型</li>
<li>将descriptor_index换为字段的特征签名Signature</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>SourceFile属性
<ul>
<li>记录生成Class文件的源码文件的名称</li>
<li>可选属性</li>
<li>结构
<ul>
<li>attribute_name_index</li>
<li>attribute_length</li>
<li>sourcefile_index
<ul>
<li>指向常量池</li>
<li>源码文件名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>ConstantValue属性
<ul>
<li>通知虚拟机为静态变量赋值</li>
<li>变量的赋值方式
<ul>
<li>非静态变量
<ul>
<li>实例构造器方法进行</li>
</ul>
</li>
<li>静态变量
<ul>
<li>类构造器中</li>
<li>使用Constant属性
<ul>
<li>使用final来修饰，并且数据类型是基本数据类型或String类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>结构
<ul>
<li>attribute_name_index</li>
<li>attribute_length
<ul>
<li>定长属性，值为2</li>
</ul>
</li>
<li>constantvalue_index
<ul>
<li>常量池中一个字面量的引用</li>
<li>u2数据类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>InnerClasses属性
<ul>
<li>记录内部类与宿主类之间的关联</li>
<li>对外部类和它的内部类生成该属性</li>
<li>结构
<ul>
<li>attribute_name_index</li>
<li>attribute_length</li>
<li>number_of_classes
<ul>
<li>表示要记录多少个内部类信息</li>
</ul>
</li>
<li>inner_classes
<ul>
<li>类型：inner_class_info
<ul>
<li>inner_class_info_index
<ul>
<li>指向常量池</li>
<li>内部类的符号引用：CONSTANT_Class_info型常量</li>
</ul>
</li>
<li>outer_class_info_index
<ul>
<li>指向常量池</li>
<li>外部类的符号引用</li>
</ul>
</li>
<li>inner_name_index
<ul>
<li>指向常量池</li>
<li>内部类的名字
<ul>
<li>匿名类值为0</li>
<li>即常量池的0号</li>
</ul>
</li>
</ul>
</li>
<li>inner_class_access_flags
<ul>
<li>内部类的访问标志</li>
</ul>
</li>
</ul>
</li>
<li>大小：number_of_classes指定</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Deprecated属性
<ul>
<li>过时标志</li>
<li>有或没有，没有属性值</li>
<li>结构
<ul>
<li>attribute_name_index</li>
<li>attribute_length</li>
</ul>
</li>
</ul>
</li>
<li>Synthetic属性
<ul>
<li>表示该类、字段或方法是由编译期自动产生的</li>
</ul>
</li>
<li>StackMapTable
<ul>
<li>位于Code属性表中的变长属性</li>
<li>虚拟机类加载的字节码验证阶段被新类型检查验证器使用</li>
<li>在编译期间将一系列验证信息直接记录在Class文件中</li>
<li>结构
<ul>
<li>attribute_name_index</li>
<li>attribute_length</li>
<li>number_of_entries</li>
<li>stack_map_frame entries
<ul>
<li>大小：number_of_entries指定</li>
<li>类型：stack_map_frame
<ul>
<li>显式或隐式代表一个字节码偏移量</li>
<li>表示执行该字节码时局部变量表和操作数栈的验证类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Signature属性
<ul>
<li>可选的定长属性</li>
<li>记录泛型中指定的类型变量或参数化类型</li>
<li>由于Java中泛型时伪泛型，使用这个属性可以使用反射获取泛型类型</li>
<li>结构
<ul>
<li>attribute_name_index</li>
<li>attribute_length</li>
<li>signature_index
<ul>
<li>指向常量池中的签名</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>BootstrapMethods属性
<ul>
<li>变长属性，位于类文件属性表中</li>
<li>保存invokedynamic指令引用的引导方法限定符</li>
<li>类文件结构的常量池中出现CONSTANT_InvokeDynamic_info类型的常量</li>
<li>结构
<ul>
<li>attribute_name_index</li>
<li>attribute_length</li>
<li>num_bootstrap_methods
<ul>
<li>引导方法限定符的数量</li>
</ul>
</li>
<li>bootstrap_methods
<ul>
<li>大小：num_bootstrap_methods指定</li>
<li>类型：bootstrap_method
<ul>
<li>bootstrap_method_ref
<ul>
<li>对常量池中CONSTANT_MethodHandle_info结构的指向</li>
</ul>
</li>
<li>num_bootsrap_arguments
<ul>
<li>指出静态参数个数</li>
</ul>
</li>
<li>bootstrap_arguments
<ul>
<li>大小：num_bootsrap_argumnets指出</li>
<li>类型：对常量池的有效索引</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重读深入理解Java虚拟机（二）—— 垃圾收集器与内存分配]]></title>
        <id>https://yuncheng1998.github.io/post/9kojaJwjx/</id>
        <link href="https://yuncheng1998.github.io/post/9kojaJwjx/">
        </link>
        <updated>2021-04-12T02:27:14.000Z</updated>
        <content type="html"><![CDATA[<p>重读深入理解Java虚拟机计划 <strong>垃圾收集器与内存分配</strong></p>
<h2 id="线程独占和线程共享区域">线程独占和线程共享区域</h2>
<h3 id="线程独立区域随线程结束回收">线程独立区域随线程结束回收</h3>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<h3 id="java堆和方法区是垃圾回收器关注的内存">Java堆和方法区是垃圾回收器关注的内存</h3>
<ul>
<li>堆上关注对象的回收</li>
<li>方法区关注常量和无用类</li>
</ul>
<h2 id="判断对象是否需要回收">判断对象是否需要回收</h2>
<h3 id="引用计数法">引用计数法</h3>
<ul>
<li>引用计数，当为0时判断需要回收</li>
<li>难以解决对象间的循环引用问题</li>
</ul>
<h3 id="可达性分析法">可达性分析法</h3>
<ul>
<li>
<p>以GC Root为起点，向下搜索，不再引用链上的对象可以回收</p>
</li>
<li>
<p>GC Root判定</p>
<ul>
<li>JVM栈中的引用对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://www.wangych.top/upload/2019/7/%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6-5693b7d0bf864fe096213eeaa802e201.jpg" alt="对象回收" loading="lazy"></figure>
<h3 id="引用">引用</h3>
<ul>
<li>
<p>为了在进行垃圾回收时更好的为对象分类，将其引用类型进行区分</p>
</li>
<li>
<p>四种引用强度</p>
<ul>
<li>
<p>强引用</p>
<ul>
<li>new出来的对象，只要强引用还在，就不会回收该对象</li>
</ul>
</li>
<li>
<p>软引用</p>
<ul>
<li>有用但非必须的对象，在即将内存溢出时进行一次回收，如果空间还不够，才将其划分到第二次回收的范围中</li>
</ul>
</li>
<li>
<p>弱引用</p>
<ul>
<li>第一次垃圾回收会直接回收掉</li>
</ul>
</li>
<li>
<p>虚引用</p>
<ul>
<li>对象被回收会得到一个系统通知</li>
</ul>
</li>
</ul>
</li>
<li>
<p>判断对象生存还是死亡</p>
</li>
</ul>
<h2 id="方法区的回收">方法区的回收</h2>
<h3 id="回收对象废弃常量和无用的类">回收对象：废弃常量和无用的类</h3>
<h3 id="废弃常量">废弃常量</h3>
<ul>
<li>如果没有引用指向这个常量，就将其回收</li>
</ul>
<h3 id="无用的类">无用的类</h3>
<ul>
<li>该类所有实例都被回收</li>
<li>类加载器被回收</li>
<li>Class对象没有被引用过，不能通过反射来访问该类的方法</li>
</ul>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<h3 id="标记清除算法">标记清除算法</h3>
<ul>
<li>
<p>效率问题</p>
</li>
<li>
<p>空间问题</p>
<ul>
<li>标记清除产生大量不连续的内存碎片，导致分配大对象时没有足够的连续的内存</li>
</ul>
</li>
</ul>
<h3 id="复制算法">复制算法</h3>
<ul>
<li>针对新生代（对象存活时间较短）</li>
<li>较大的Eden区和两块Survivor区8:1比例</li>
<li>每次将Eden和Survivor存活的对象一次性复制到另外一块Survivor中</li>
<li>为防止Survivor的空间不够用需要老年代进行分配担保</li>
</ul>
<h3 id="标记整理算法">标记整理算法</h3>
<ul>
<li>针对老年代（对象存活时间较长）</li>
<li>让存活对象向一端移动，然后清理掉端边界以外的内存</li>
</ul>
<h3 id="分代收集算法">分代收集算法</h3>
<ul>
<li>根据对象存活周期不同将内存划分为新生代和老年代</li>
<li>新生代使用复制算法</li>
<li>老年代使用标记清除或标记整理</li>
</ul>
<h2 id="hotspot算法实现">HotSpot算法实现</h2>
<h3 id="枚举根节点">枚举根节点</h3>
<ul>
<li>
<p>GC Root主要存在于全局引用和执行上下文中，检查消耗时间</p>
</li>
<li>
<p>在确保一致性的快照中执行</p>
<ul>
<li>stop the world</li>
<li>枚举根节点时必须停顿</li>
</ul>
</li>
<li>
<p>准确式GC</p>
<ul>
<li>OopMap来获得对象引用存在的位置</li>
<li>在类加载完成时，HotSpot将对象在内存上偏移量以及数据类型计算出来</li>
</ul>
</li>
</ul>
<h3 id="安全点">安全点</h3>
<ul>
<li>
<p>引起引用变化的指令较多，为每一条指令都生成对应OopMap需要大量额外空间</p>
</li>
<li>
<p>只在特定位置上记录，到达安全点才会GC</p>
</li>
<li>
<p>选定标准：程序长时间执行，例如方法调用、循环跳转、异常跳转等</p>
</li>
<li>
<p>让所有线程都跑到最近安全点后停顿</p>
<ul>
<li>
<p>抢先式中断</p>
<ul>
<li>不需要代码主动配合，所有线程中断，有线程没有中断在安全点上就恢复线程到安全点</li>
</ul>
</li>
<li>
<p>主动式中断</p>
<ul>
<li>线程轮询中断标志，需要中断时将其挂起在经过的安全点上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="安全区域">安全区域</h3>
<ul>
<li>一块代码片段内，引用关系不会发生变化，该区域内的GC是安全的</li>
<li>对安全点的扩展</li>
<li>线程执行到Safe Region中的代码时，表示自己，GC时不需要考虑这些线程，当离开时检查枚举根节点是否正在执行，等待完成信号后离开</li>
</ul>
<figure data-type="image" tabindex="2"><img src="http://www.wangych.top/upload/2019/7/%E5%AE%89%E5%85%A8%E5%8C%BA-5e578f8c5e3b46269b602ebede205231.jpg" alt="安全区" loading="lazy"></figure>
<h2 id="垃圾收集器">垃圾收集器</h2>
<h3 id="新生代">新生代</h3>
<ul>
<li>
<p>Serial</p>
<ul>
<li>单线程的收集器</li>
<li>采用复制算法</li>
</ul>
</li>
<li>
<p>ParNew</p>
<ul>
<li>Serial的多线程版本</li>
</ul>
</li>
<li>
<p>Parallel Scavenge</p>
<ul>
<li>吞吐量优先收集器</li>
<li>目的为达到一个可控制的吞吐量</li>
<li>吞吐量=用户代码时间/总时间</li>
</ul>
</li>
</ul>
<h3 id="老年代">老年代</h3>
<ul>
<li>
<p>Serial Old</p>
<ul>
<li>Serial的老年代版本</li>
<li>标记整理算法</li>
</ul>
</li>
<li>
<p>Parallel Old</p>
<ul>
<li>Serial Old的多线程版本</li>
</ul>
</li>
<li>
<p>CMS</p>
<ul>
<li>
<p>目标为获取最短回收停顿时间，提高响应速度</p>
</li>
<li>
<p>标记-清除算法 Mark sweep</p>
</li>
<li>
<p>运作过程</p>
<ul>
<li>
<p>初始标记</p>
<ul>
<li>stop the world，单线程</li>
<li>标记GC Root直接关联的对象，时间短</li>
</ul>
</li>
<li>
<p>并发标记</p>
<ul>
<li>GC Roots Tracing</li>
<li>时间较长，用户程序会导致标记变动</li>
<li>与用户线程并发</li>
</ul>
</li>
<li>
<p>重新标记</p>
<ul>
<li>stop the world，多线程重新标记</li>
<li>针对并发标记阶段产生的变动重新标记</li>
</ul>
</li>
<li>
<p>并发清除</p>
<ul>
<li>与用户线程并发执行</li>
</ul>
</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>
<p>对CPU资源敏感</p>
</li>
<li>
<p>无法处理浮动垃圾</p>
<ul>
<li>
<p>并发清理阶段与用户线程并发执行，产生的新垃圾需要等到下一次GC时回收</p>
</li>
<li>
<p>需要预留部分空间给并发收集时程序使用</p>
</li>
<li>
<p>可能出现Concurrent Mode failure导致另一次Full GC</p>
<ul>
<li>临时启动Serial Old收集器重新进行Tenured generation的收集</li>
</ul>
</li>
</ul>
</li>
<li>
<p>空间碎片</p>
<ul>
<li>
<p>由于采用标记清除算法导致</p>
</li>
<li>
<p>可能缺乏足够连续内存存放大对象</p>
</li>
<li>
<p>解决</p>
<ul>
<li>
<p>-XX:+UseCMSCompactAtFullCollection参数</p>
<ul>
<li>在要进行Full GC时进行内存碎片整理合并</li>
</ul>
</li>
<li>
<p>-XX:CMSFullGCsBeforeCollection参数</p>
<ul>
<li>设置几次不压缩的Full GC后跟一次带压缩的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="g1">G1</h3>
<ul>
<li>
<p>特点</p>
<ul>
<li>并行与并发</li>
<li>分代收集</li>
<li>空间整合</li>
<li>可预测的停顿</li>
</ul>
</li>
<li>
<p>Region</p>
<ul>
<li>
<p>G1收集器不进行分代收集，将内存划分为大小相同的Region</p>
</li>
<li>
<p>新生代和老年代是一部分Region的集合</p>
</li>
<li>
<p>跟踪每个Region中垃圾堆积的价值大小，维护优先列表，每次根据允许收集的时间优先回收价值最大的Region</p>
</li>
<li>
<p>Remembered Set</p>
<ul>
<li>每个Region都有自己的Set</li>
<li>Region间存在对象的引用关系，使用Remembered Set避免在回收新生代过程中查找GC Roots时全堆扫描</li>
<li>当程序对引用类型的数据进行写操作时，检查引用的对象是否在其他Region中，如果时通过CardTable将引用信息记录到Set中</li>
</ul>
</li>
</ul>
</li>
<li>
<p>运行过程</p>
<ul>
<li>
<p>初始标记</p>
<ul>
<li>标记GC Root能直接关联到的对象</li>
</ul>
</li>
<li>
<p>并发标记</p>
<ul>
<li>从GC Root开始对堆中的对象进行可达性分析</li>
<li>耗时长，与用户程序并发执行</li>
</ul>
</li>
<li>
<p>最终标记</p>
<ul>
<li>修正在并发标记期间因用户程序继续运作导致标记变动</li>
</ul>
</li>
<li>
<p>筛选回收</p>
<ul>
<li>对Region的回收价值和成本进行排序</li>
<li>根据用户期望的停顿时间制定回收计划</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存分配与回收策略">内存分配与回收策略</h2>
<h3 id="对象的分配">对象的分配</h3>
<ul>
<li>
<p>主要在堆上</p>
<ul>
<li>
<p>优先在新生代的Eden区分配</p>
</li>
<li>
<p>大对象直接进入老年代</p>
<ul>
<li>-XX:PretenureSizeThreshold参数</li>
<li>设置大于对象大于某个值后直接分配在老年代</li>
</ul>
</li>
<li>
<p>长期存活的对象进入老年代</p>
<ul>
<li>
<p>使用对象年龄Age计数器</p>
</li>
<li>
<p>对象在Eden出生，第一次Minor GC后放入Survivor，Age=1。没熬过一次Minor GC对象年龄+1，到达阈值（默认15）后进入老年代</p>
<ul>
<li>+XX:MaxTenuringThreshold=15</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>也可能被拆散为标量类型间接在栈上分配</p>
</li>
</ul>
<h3 id="两种情况进入老年代">两种情况进入老年代</h3>
<ul>
<li>Age&gt;MaxTenuringThreshold</li>
<li>Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象直接进入老年代</li>
</ul>
<h3 id="空间分配担保">空间分配担保</h3>
<figure data-type="image" tabindex="3"><img src="http://www.wangych.top/upload/2019/7/%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D-4038b245f9ee4f1c89ee63a27d822c3c.jpg" alt="空间分配担保" loading="lazy"></figure>
<h3 id="minor-gc与full-gc">Minor GC与Full GC</h3>
<ul>
<li>Minor GC是新生代GC，对象朝生夕灭，回收频繁，速度较快</li>
<li>Full GC/Major GC是老年代GC，慢</li>
</ul>
<p><em>XMind: ZEN - Trial Version</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重读深入理解Java虚拟机（一）—— 读深入理解JVM之内存管理]]></title>
        <id>https://yuncheng1998.github.io/post/BSpDNhcfw/</id>
        <link href="https://yuncheng1998.github.io/post/BSpDNhcfw/">
        </link>
        <updated>2021-04-12T02:25:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="jvm内存管理">JVM内存管理</h1>
<p>最近在读 <a href="https://book.douban.com/subject/24722612/"><em>深入理解 Java虚拟机</em></a>，这里列出一下JVM内存管理部分大纲，还需配合该书进行学习。</p>
<h3 id="运行时数据区">运行时数据区</h3>
<h4 id="线程隔离">线程隔离</h4>
<ul>
<li>程序计数器
<ul>
<li>Java方法
<ul>
<li>虚拟机字节码指令的地址</li>
</ul>
</li>
<li>Native方法
<ul>
<li>计数值为空</li>
</ul>
</li>
<li>唯一一个没有规定OutOfMemoryError的区域</li>
</ul>
</li>
<li>Java虚拟机栈
<ul>
<li>描述方法执行的内存模型
<ul>
<li>方法执行时创建栈帧
<ul>
<li>局部变量表
<ul>
<li>编译期可知的基本数据类型和引用类型</li>
<li>64位长度的long和double类型占用2个局部变量空间（2 slot）</li>
<li>编译期间大小分配完成，运行期间不会再动态更改</li>
</ul>
</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口</li>
</ul>
</li>
<li>每个方法对应一个栈帧入栈和出栈的过程</li>
</ul>
</li>
<li>异常
<ul>
<li>StackOverflowError
<ul>
<li>线程请求的栈深度超过虚拟机允许的</li>
</ul>
</li>
<li>OutOfMemoryError
<ul>
<li>虚拟机栈动态扩展时无法申请到足够的内存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>本地方法栈
<ul>
<li>为Native方法服务</li>
<li>Sun HotSpot将本地方法栈和虚拟机栈合二为一</li>
</ul>
</li>
</ul>
<h4 id="线程共享">线程共享</h4>
<ul>
<li>方法区
<ul>
<li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</li>
<li>Java虚拟机规范对方法区管理宽松
<ul>
<li>不需要连续内存</li>
<li>可以固定大小或扩展</li>
<li>可以不选择垃圾收集
<ul>
<li>对常量池的回收和对类型的卸载</li>
<li>回收成绩难以令人满意</li>
</ul>
</li>
</ul>
</li>
<li>运行时常量池
<ul>
<li>存放class文件
<ul>
<li>Class文件有常量池信息，存放编译期生成的各种字面量和符号引用
<ul>
<li>在类加载后进入方法区的运行时常量池</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>发生区内存大小无法满足需要时
<ul>
<li>OutOfMemoryError</li>
</ul>
</li>
</ul>
</li>
<li>堆
<ul>
<li>存放对象实例</li>
<li>垃圾收集的主要区域</li>
<li>堆的划分
<ul>
<li>内存分配的角度
<ul>
<li>多个线程私有的分配缓冲区</li>
</ul>
</li>
<li>内存回收的角度
<ul>
<li>根据分代收集法细分
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>逻辑上连续即可</li>
<li>可以固定大小也可以是可扩展的</li>
</ul>
</li>
</ul>
<h3 id="直接内存">直接内存</h3>
<h4 id="堆外内存">堆外内存</h4>
<h4 id="nio类">NIO类</h4>
<ul>
<li>基于通道与缓冲区的I/O方式</li>
<li>使用Native函数直接分配堆外内存</li>
<li>通过Java堆中的DirectByteBuffer对象作为堆外内存的引用</li>
<li>避免在Java堆和Native堆中来回复制数据</li>
</ul>
<h3 id="对象的创建">对象的创建</h3>
<h4 id="创建对象的过程">创建对象的过程</h4>
<ul>
<li>遇到new指令，检查该类是否已经被加载、解析、初始化</li>
<li>加载后确定了内存大小，从Java堆中划出内存
<ul>
<li>内存分配方式
<ul>
<li>指针碰撞</li>
<li>空闲列表</li>
</ul>
</li>
<li>Java堆是否规整选择分配方式
<ul>
<li>根据垃圾收集器是否带有压缩决定</li>
</ul>
</li>
<li>并发情况下修改指针
<ul>
<li>对分配内存空间的动作进行同步处理
<ul>
<li>采用CAS配上失败重试的方式保证原子性</li>
</ul>
</li>
<li>将内存分配动作按照线程划分在不同的空间中
<ul>
<li>每个线程在Java堆中预先分配一小块内存，本地线程分配缓冲</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>将内存空间都初始化为零值
<ul>
<li>成员变量默认的数据类型</li>
</ul>
</li>
<li>虚拟机对对象做设置，设置对象头
<ul>
<li>对应类</li>
<li>怎样找到类的元数据信息</li>
<li>对象的哈希码</li>
<li>对象的CG分代年龄</li>
</ul>
</li>
</ul>
<h4 id="对象的内存布局">对象的内存布局</h4>
<ul>
<li>对象头
<ul>
<li>存储对象自身运行时数据（Mark Word）</li>
<li>类型指针（指向类元数据的指针）
<ul>
<li>JVM通过类型指针确定对象是哪个类</li>
<li>查找类时不需要经过对象本身</li>
</ul>
</li>
</ul>
</li>
<li>实例数据
<ul>
<li>对象真正存储的有效信息</li>
<li>受到JVM分配参数策略和源码中字段定义顺序的影响</li>
</ul>
</li>
<li>对齐填充
<ul>
<li>HotSpot中对象的起始地址必须是8字节的整数倍</li>
<li>通过对齐填充来补全</li>
</ul>
</li>
</ul>
<h4 id="对象的访问定位">对象的访问定位</h4>
<ul>
<li>通过栈上的reference数据来操作堆上的具体对象</li>
<li>引用定位堆上对象的方式
<ul>
<li>句柄访问
<ul>
<li>堆的划分
<ul>
<li>句柄池
<ul>
<li>句柄对象</li>
</ul>
</li>
<li>实例池
<ul>
<li>实例对象</li>
</ul>
</li>
</ul>
</li>
<li>句柄对象
<ul>
<li>到对象实例数据的指针
<ul>
<li>指向实例池</li>
</ul>
</li>
<li>到对象类型数据的指针
<ul>
<li>指向方法区</li>
</ul>
</li>
</ul>
</li>
<li>优点
<ul>
<li>稳定的句柄地址
<ul>
<li>移动对象只要改变句柄对象的实例数据指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>指针直接访问
<ul>
<li>堆中实例数据中存在到对象类型数据的指针
<ul>
<li>指向方法区的对象类型数据</li>
</ul>
</li>
<li>优点
<ul>
<li>速度快</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法周记（启发式搜索、有限内存中大数据量中查找、找出数组中超过一半的数、不连续的整数中找出最大间隔））]]></title>
        <id>https://yuncheng1998.github.io/post/lXK0TE-8V/</id>
        <link href="https://yuncheng1998.github.io/post/lXK0TE-8V/">
        </link>
        <updated>2021-04-11T15:27:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="启发式搜索">启发式搜索</h3>
<p>在 <em>《漫画算法》</em> 中看到 <code>A*寻路算法</code>，这是一种用于寻找最短路径的算法，例如在有障碍的图中找到从A到B的最短路径，就会应用这个算法。将地图以方格进行划分，A和B的位置分别占据一个方格，程序维持一个OpenList和CloseList来存储新获得的节点和已经检查过的节点，每个方格存储三个特性(到起点的距离s，到终点的距离e，二者只和h)。第一次将A周围的四个方格放到OpenList中，将A作为这四个方格的父节点，然后选出h最小的放到CloseList中，将这个方格周围的方格再进行相同的操作，直到将终点放到CloseList中。另外需要记录每一个方格的父节点，这样当只需要根据父节点从终点向上回溯就可以找到最短路径。</p>
<h3 id="有限内存中大数据量中查找">有限内存中大数据量中查找</h3>
<ul>
<li>如何在20亿个整数中查找一个数是否存在<br>
如果将每个整数都使用int来存储，那么需要使用大约要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>∗</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2^{31} * 2^{5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span> 共8G内存。那么若内存有限，这种使用int来存储的方法就不能使用，这就可以使用Bitmap来进行改进。根据整数的范围至多有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> 个数，因此可以申请长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> bit的空间来存储这些数，每一个bit代替1个数，这样只需要 512MB的内存空间即可存入。</li>
<li>如何在20亿个整数中找到出现次数最多的整数<br>
要记录出现的次数就不能使用Bitmap，若要保证不会超过内存，那么需要对其进行分批处理。如果使用Hash表来进行记录，每条记录需要占用两个int的空间，即8Byte，这样需要16GB的内存。因此需要考虑进行分批处理，若内存只有2GB，则将其分为10份，让每份数据量只占用1.6GB，由于给出的数未必是均匀分布的，因此可以设计一个好的Hash映射函数，将其均匀的映射到20亿的数值范围内。</li>
<li>如何在40亿个整数中找到出现次数最多的整数<br>
当数据量达到10亿时，我们还需要考虑假如某个数据出现的次数太多，超过了int整数的表示范围应该如何处理，对于40亿级别，由于int类型表示最大整数在21亿左右，因此将其初值设置为int表示的最小负数值即可，即 <code>-2147483648</code></li>
</ul>
<h3 id="找出数组中超过一半的数">找出数组中超过一半的数</h3>
<p>如果一个数组中有超过一半的数，那么将任意两个不相等的数相互抵消，最后剩下的数必然是超过一半的数。这个算法前提是必须保证存在这种数，如果不能保证，仍然需要排序后找出中间的数，然后与第一个数和最后一个数比较。如果n为奇数，那么需要保证<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>三个位置上的数有两个相等。如果n为偶数，那么需要保证<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>相等或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n/2-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>相等。</p>
<h3 id="不连续的整数中找出最大间隔">不连续的整数中找出最大间隔</h3>
<p>若给出的数不多，可以使用计数排序，即使用下标进行计数。用每个数减去最小的数，然后使用bitmap来储存，然后根据0连续出现的次数来确定。如果数的间隔较大，那么可以使用桶排序，例如共有15个数，最小的数为0，最大数为10w，那么可以分成10个桶，分别存储0-1w，1-2w，...。现根据空桶进行查找，如都集中在某个桶那么就再次分桶计数，直到找出间隔最大的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法周记（第K个最大元素、最长连续序列、螺旋矩阵、股票买卖、合并有序数组、被围绕的区域、分割回文串）]]></title>
        <id>https://yuncheng1998.github.io/post/DX1hNN3hk/</id>
        <link href="https://yuncheng1998.github.io/post/DX1hNN3hk/">
        </link>
        <updated>2021-04-11T15:24:52.000Z</updated>
        <content type="html"><![CDATA[<h3 id="数组中第k个最大的元素">数组中第k个最大的元素</h3>
<p>找数组中第k大的元素</p>
<pre><code class="language-java">class Solution {

    /**
     * 将其由小到大排序，选定一个位置作为分割
     * 找第k大的数
     * @param nums
     * @param k
     * @return
     */
    public int findKthLargest(int[] nums, int k) {
        // 首先使用倒数k作为分割点进行查找
        return findK(nums, 0, nums.length -1, nums.length - k);
    }

    /**
     *
     * @param nums 数组
     * @param start 开始
     * @param end 结束
     * @param k 第k大
     * @return
     */
    public int findK(int[] nums, int start, int end, int k) {
        if (start == end) {
            return nums[start];
        }
        int pivot = nums[(start + end)/2];
        int i = start;
        int j = end;
        while (i &lt;= j) {
            while (nums[i] &lt; pivot) {
                i++;
            }
            while (nums[j] &gt; pivot) {
                j--;
            }
            if (i &lt;= j) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
                j--;
            }
        }
        // 判断k在选定点前面还是后面，对选定的部分进行排序
        if (k &gt;= (i-start)) {
            return findK(nums, i, end, k-i+start);
        } else {
            return findK(nums, start, i-1, k);
        }
    }
}
</code></pre>
<h3 id="最长连续序列">最长连续序列</h3>
<pre><code class="language-java">class Solution {
    /**
     * 最长连续序列，注意最长连续序列中的任意一个数
     * @param nums
     * @return
     */
    public int longestConsecutive(int[] nums) {
        // 记录该字符所在的最长子序列的序列长度
        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        // 最长子序列长度
        int res = 0;
        for (int t : nums) {
            // 如果map中包含说明已经计算过
            if (map.containsKey(t)) {
                continue;
            }
            // 获取t-1所在的最长连续序列的长度
            int left = map.getOrDefault(t - 1, 0);
            // 获取t+1所在的最长连续序列的长度
            int right = map.getOrDefault(t + 1, 0);
            // 最终长度
            int count = left + right + 1;
            // 更新t、t-1、t+1的值
            map.put(t, count);
            if (left &gt; 0) {
                map.put(t - left, count);
            }
            if (right &gt; 0) {
                map.put(t + right, count);
            }
            // 更新最长长度
            res = Math.max(res, count);
        }
        return res;
    }
}
</code></pre>
<h3 id="螺旋矩阵">螺旋矩阵</h3>
<pre><code class="language-java">/**
 * 顺时针螺旋顺序
 */
class Solution {
    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        if (matrix.length == 0) {
            return ans;
        }

        int startR = 0, endR = matrix.length - 1;
        int startC = 0, endC = matrix[0].length - 1;

        while (startR &lt;= endR &amp;&amp; startC &lt;= endC) {
            // 上面一行遍历
            for (int c = startC; c &lt;= endC; c++) {
                ans.add(matrix[startR][c]);
            }
            // 右边一列遍历，起始位置应该start+1
            for (int r = startR + 1; r &lt;= endR; r++) {
                ans.add(matrix[r][endC]);
            }
            // 倒序遍历
            if (startR &lt; endR &amp;&amp; startC &lt; endC) {
                // 下面一行遍历:从倒数第二个到第一个
                for (int c = endC - 1; c &gt; startC; c--) {
                    ans.add(matrix[endR][c]);
                }
                // 左边一行遍历:从倒数第二个到正数第二个
                for (int r = endR; r &gt; startR; r--) {
                    ans.add(matrix[r][startC]);
                }
            }
            // 矩阵内缩
            startR++;
            endR--;
            startC++;
            endC--;
        }
        return ans;
    }
}
</code></pre>
<h3 id="螺旋矩阵ii">螺旋矩阵II</h3>
<pre><code class="language-java">class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int startC = 0, endC = n - 1;
        int startR = 0, endR = n - 1;
        int i = 1;
        while (startC &lt;= endC &amp;&amp; startR &lt;= endR) {
            for (int c = startC; c &lt;= endC; c++) {
                res[startR][c] = i++;
            }
            for (int r = startR + 1; r &lt;= endR; r++) {
                res[r][endC] = i++;
            }
            if (startC &lt; endC &amp;&amp; startR &lt; endR) {
                for (int c = endC - 1; c &gt; startC; c--) {
                    res[endR][c] = i++;
                }
                for (int r = endR; r &gt; startR; r--) {
                    res[r][startC] = i++;
                }
            }
            startC++;
            startR++;
            endC--;
            endR--;
        }
        return res;
    }
}
</code></pre>
<h3 id="买卖股票的最佳时机ii">买卖股票的最佳时机II</h3>
<pre><code class="language-java">class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length &lt; 2) {
            return 0;
        }
        int max = prices[prices.length - 1];
        int min = max;
        int res = 0;
        for (int i = prices.length - 1; i &gt;= 0; i--) {
            if (prices[i] &gt;= max) {
                res = res + max - min;
                max = prices[i];
                min = max;
            } else if (prices[i] &lt;= min) {
                min = prices[i];
            } else {
                res = res + max - min;
                max = prices[i];
                min = max;
            }
        }
        res = res + max - min;
        return res;
    }
}
</code></pre>
<h3 id="合并两个有序数组">合并两个有序数组</h3>
<p>给出两个有序数组，将B数组合并进A数组<br>
方法：倒序插入<br>
获得合并后的尾指针和两个数组的尾指针，逐渐向内移动尾指针，比较两个数组中的值，决定将哪一个赋值给对应的位置</p>
<pre><code class="language-java">class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m + n - 1, j = m - 1, k = n - 1;
        while (j &gt;= 0 &amp;&amp; k &gt;= 0) {
            nums1[i--] = (nums1[j] &gt; nums2[k]) ? nums1[j--] : nums2[k--];
        }
        while (k &gt;= 0) {
            nums1[i--] = nums2[k--];
        }
    }
}
</code></pre>
<h3 id="被围绕的区域">被围绕的区域</h3>
<ul>
<li>DFS</li>
</ul>
<pre><code class="language-java">class Solution {
    public void solve(char[][] board) {
        if(board == null || board.length == 0) return;
        int m = board.length;
        int n = board[0].length;
        // 对于在边界出现的O进行DFS
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                boolean isEdge = (i == 0 || j == 0 || i == m - 1 || j == n - 1);
                if (isEdge &amp;&amp; board[i][j] == 'O') {
                    dfs(board, i, j);
                }
            }
        }
        // DFS后，无法替换的O已经被置换成#，这里将其置换回来
        for (int i = 0; i &lt; m; i++) {
            for (int j = 0; j &lt; n; j++) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
                if (board[i][j] == '#') {
                    board[i][j] = 'O';
                }
            }
        }
    }

    /**
     * 深度优先遍历递归
     * @param board
     * @param i
     * @param j
     */
    public void dfs(char[][] board, int i, int j) {
        // 对非边界的O进行查找，替换为#
        if (i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length || board[i][j] == 'X' || board[i][j] == '#') {
            return;
        }
        board[i][j] = '#';
        dfs(board, i - 1, j);
        dfs(board, i + 1, j);
        dfs(board, i, j - 1);
        dfs(board, i, j + 1);
    }

}
</code></pre>
<h3 id="分割回文串">分割回文串</h3>
<pre><code class="language-java">class Solution {
    private String s;
    private List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();

    /**
     * 验证s[i,j]子串是否是回文
     * @param i i
     * @param j j
     * @return a[i,j]是否为回文
     */
    private boolean validate(int i, int j){
        while(i &lt; j){
            if(s.charAt(i) != s.charAt(j)) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }

    /**
     *
     * @param s 字符串
     * @param list  将分割的字符串存储在 list中
     * @param index index，在字符串中的下标
     */
    private void f(String s, List&lt;String&gt; list, int index){
        // 当下标移动至结尾时，就可以将其添加到result中
        if(index &gt;= s.length()){
            result.add(new ArrayList&lt;&gt;(list));
            return;
        }
        // 从index开始判断s[index, i]子串是否是回文串
        for(int i = index; i &lt; s.length(); i++){
            // 如果是回文串，放入list中，然后对
            if(validate(index, i)){
                list.add(s.substring(index, i + 1));
                f(s, list, i + 1);
                list.remove(list.size() - 1);
            }
        }
    }

    public List&lt;List&lt;String&gt;&gt; partition(String s) {
        if(s.equals(&quot;&quot;)||s.length()==0) {
            return result;
        }
        this.s=s;
        f(s, new ArrayList&lt;&gt;(), 0);
        return result;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[n&(n-1) 特性、异或、Bitmap处理用户画像]]></title>
        <id>https://yuncheng1998.github.io/post/VpOnun9ms/</id>
        <link href="https://yuncheng1998.github.io/post/VpOnun9ms/">
        </link>
        <updated>2021-04-11T15:24:19.000Z</updated>
        <content type="html"><![CDATA[<h3 id="nn-1-特性">n&amp;(n-1) 特性</h3>
<p>这是在一篇公众号看到的算法，主要思想为</p>
<blockquote>
<p>n=n&amp;(n-1)可以消去从右到左的第一个1</p>
</blockquote>
<p>这个特性可以快速解出一些二进制相关的问题诸如</p>
<ul>
<li>判断是一个数n是否只2的幂次方，因为该数必定只有一个1，所以只需要判断<code>n&amp;(n-1)</code>是否为0，这样在O(1)的复杂度就可以解出</li>
<li><em>《编程之美》</em> 中求二进制中1的个数也使用了这个方法，每执行一次就可以减少一个1，最终为0时执行的次数就是1的个数</li>
</ul>
<h3 id="异或">异或</h3>
<p>和同事在讨论位运算时，同事说到用异或运算交换两个数的经典题目，由此想到了面试中被问到的道题目</p>
<blockquote>
<p>1-10万中缺失两个数，如何找到？</p>
</blockquote>
<p>如果是缺失了一个数，可以用1到10万求和减去给出数的合，或者使用1到10万异或再去异或给出的所有数，得到的就是缺失的那个数。两个数可以使用两种方法的结合，求出他们的和，再求出他们的异或，然后再有限的范围内遍历。<br>
另外还有一种方法是在 <em>《编程之美》</em> 中给出的，将给出的数异或后，由于有缺失，因此不会为0，必然有一位为1，因此可以将给出的数按照该位为1或0分为两个列表，这样缺失的两个数就会被分到两个列表中，再将1到10万按照相同的方法分到这两个列表中，这样两个列表中的数分别做异或，就求出了两个缺失的数。</p>
<h3 id="bitmap处理用户画像">Bitmap处理用户画像</h3>
<p>位图算法在处理大量数据时十分高效快捷，特别是可以与位运算结合使用，极大的提高了运算的效率。在 <em>《漫画算法》</em> 中提出了一个用户标签的问题，在刻画用户画像系统时，通常有多种标签来将用户分类，如果是通过在数据库中增加列，然后在运用SQL语句来实现查找一类用户，那么随着标签越来越多，这种方法十分低效。<br>
<em>Bitmap</em> 可以解决这一问题，位图算法的本质是利用 <em>1bit</em> 来存储一个数据，对于用户画像系统，可以使用 <em>Bitmap</em> 来存储所有的用户ID，而每个标签使用一个 <em>Bitmap</em> 来表示。<br>
假若一共有16个用户，ID为1,3和10的用户喜欢游泳，那么游泳标签 <em>SwimMap</em> 中的倒数第1位和倒数第10位为1，那么该map的值为 <code>000001000001010</code>，若ID为3,5和10的用户是学生，那么 <em>StudentMap</em> 的值为 <code>000001000101000</code></p>
<ul>
<li>要筛选喜欢游泳的学生，只需要 <code>StudentMap &amp; SwimMap</code> 即可得到 <code>000001000001000</code>，得到结果为3和10。</li>
<li>要筛选喜欢游泳或者喜欢篮球，则 <code>SwimMap | BasketBallMap</code></li>
<li>要筛选非学生，需要使用全量位图 <code>AllUserMap^StundentMap</code>，因为申请的空间必然是大于实际用户数的，因此需要维持一个全量位图，而不能简单的取非，会有很多的空用户ID。</li>
<li></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法周记（两数之和、整数反转、最接近的三数之和、盛水最多的容器、全排列、最长公共前缀、爬楼梯）]]></title>
        <id>https://yuncheng1998.github.io/post/ffJJJTXS7/</id>
        <link href="https://yuncheng1998.github.io/post/ffJJJTXS7/">
        </link>
        <updated>2021-04-11T15:18:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="两数之和">两数之和</h3>
<p>对于链表问题，有时候可以自己设置一个head节点，然后在返回时返回head.next，虽然在程序中多出了一个节点，但可以很好的简化程序的逻辑。另外对于相加问题，要考虑好最后一位的进位问题。</p>
<pre><code class="language-java">class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int carry = 0;
        int sum = 0;
        ListNode head = new ListNode(0);
        ListNode p = head;
        int val1, val2;
        while (l1 != null || l2 != null) {
            if (l1 == null) {
                val1 = 0;
            } else {
                val1 = l1.val;
                l1 = l1.next;
            }
            if (l2 == null) {
                val2 = 0;
            } else {
                val2 = l2.val;
                l2 = l2.next;
            }
            sum = val1 + val2 + carry;
            carry = sum/10;
            p.next = new ListNode(sum%10);
            p = p.next;
        }
        if (carry &gt; 0) {
            p.next = new ListNode(carry);
        }
        return head.next;
    }
}
</code></pre>
<h3 id="整数反转">整数反转</h3>
<p>注意对边界条件的判断，本题要求的是超过表示范围后返回0，对边界的判断应该在计算出结果之前来检验。对于本题目中计算s的表达式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mi>s</mi><mo>∗</mo><mn>10</mn><mo>+</mo><mi>p</mi><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">s=s* 10 + pop</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span></span></span></span> ，如果计算后的结果满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>&gt;</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s&gt;value_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么计算前需要满足下面两个条件之一<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mo>∗</mo><mi>s</mi><mo>&gt;</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">10*s&gt;value_{max}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mi mathvariant="normal">/</mi><mn>10</mn><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>p</mi><mo>&gt;</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">s=value_{max}/10, pop&gt;7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span><br>
同理要满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>&lt;</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s&lt;value_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，满计算前需要满足下面两个条件之一<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mo>∗</mo><mi>s</mi><mo>&lt;</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">10*s&lt;value_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><msub><mi>e</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mi mathvariant="normal">/</mi><mn>10</mn><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>p</mi><mo>&lt;</mo><mo>−</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">s=value_{min}/10, pop&lt;-8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">8</span></span></span></span></p>
<pre><code class="language-java">class Solution {
    public int reverse(int x) {
        int s = 0;
        int pop = 0;
        while (x != 0) {
            pop = x%10;
            x = x/10;
            if (s &gt; Integer.MAX_VALUE/10 || (s == Integer.MAX_VALUE/10 &amp;&amp; pop &gt; 7)) {
                return 0;
            }
            if (s &lt; Integer.MIN_VALUE/10 || (s == Integer.MIN_VALUE/10 &amp;&amp; pop &lt; -8)) {
                return 0;
            }
            s = s*10 + pop;
        }
        return s;
    }
}
</code></pre>
<h3 id="最接近的三数之和">最接近的三数之和</h3>
<p>本题目与三数之和解法近似，使用双指针法，先将数组排序，然后每次选定一个数为基准，头尾指针向内移动比较与目标值的接近度。如果大于目标值，则移动尾指针，否则移动头指针。</p>
<pre><code class="language-java">public int threeSumClosest(int[] nums, int target) {
        if (nums.length &lt; 3) {
            return 0;
        }
        Arrays.sort(nums);
        int temp = nums[0] + nums[1] + nums[2];
        for (int i = 0; i &lt; nums.length - 2; i++) {
            int difference = target - nums[i];
            int start = i + 1, end = nums.length - 1;
            while (start &lt; end) {
                // 如果num[i] + num[start] + num[end] 更接近target 更新temp
                if (Math.abs(target - temp) &gt; Math.abs(difference - nums[start] - nums[end])) {
                    temp = nums[i] + nums[start] + nums[end];
                }
                // 大于则end--，小于则start++
                if (nums[start] + nums[end] &gt; difference) {
                    end--;
                } else {
                    start++;
                }
            }

        }
        return temp;
    }
</code></pre>
<h3 id="盛水最多的容器">盛水最多的容器</h3>
<figure data-type="image" tabindex="1"><img src="https://yuncheng1998.github.io/post-images/1618154398481.png" alt="盛水最多的容器" loading="lazy"></figure>
<p>如下图所示，容量的计算公式如下所示<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>a</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo><mo>∗</mo><mo>(</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">capacity=min(num[i], num[j])*(j-i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span><br>
也可以使用双指针来进行求解，头尾指针向内移动，由于容量由最短的柱子决定，因此先移动较短的柱子，每次重新计算容量，判断是否要更新最大值</p>
<pre><code class="language-java">class Solution {
    public int maxArea(int[] height) {
        int capacity = 0;
        int left = 0;
        int right = height.length - 1;
        while (left &lt; right) {
            int temp = Math.min(height[left], height[right]) * (right - left);
            capacity = Math.max(temp, capacity);
            // 如果右边的比左边的矮，让右边向内移动
            if (height[left] &gt; height[right]) {
                right--;
            } else {
                left++;
            }
        }
        return capacity;
    }
}
</code></pre>
<h3 id="全排列">全排列</h3>
<p>全排列算法是回溯法的应用，全排列计算时本质是俩俩数的交换。将整个全排列树画出后如下图所示（来源 leetCode）<br>
<img src="https://yuncheng1998.github.io/post-images/1618154427131.png" alt="全排列树" loading="lazy"><br>
可以看出第一层是将第一个位置与后面位置上的数依次交换后得到的结果，第二次是第二个数与后面位置上的数依次交换后得到的结果，第三层是第三个数与后面数依次交换的结果，知道要交换的数的位置等于数组的长度，停止交换得到的所有数组就是全排列。<br>
如果使用回溯法，首先由<code>swap(0,0), swap(1,1), swap(2,2)</code><br>
求得[1,2,3]后下一次递归的层数为3，和len相等，因此收入最终结果。<br>
回溯需要还原之前的交换来得到原来的排列，前面的回溯为<code>swap(2,2), swap(1,1)</code>还原到层数后继续下一步应进行的是<code>swap(1,2)</code>，这样依次递归将所有的全排列得到。</p>
<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();
        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        for (int i : nums) {
            list.add(i);
        }
        int len = nums.length;
        backtrack(len, list, result, 0);
        return result;
    }

    private void backtrack(int len, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result, int first) {
        if (len == first) {
            result.add(new ArrayList&lt;&gt;(list));
        }
        for (int i = first; i &lt; len; i++) {
            Collections.swap(list, first, i);
            backtrack(len, list, result, first + 1);
            Collections.swap(list, first, i);
        }
    }
}
</code></pre>
<h3 id="最长公共前缀">最长公共前缀</h3>
<p>给定一组字符串，求这组字符串最长公共子前缀。</p>
<blockquote>
<p>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]<br>
输出: &quot;fl&quot;</p>
</blockquote>
<p>首先需要理解前缀的含义，即 <em>prefix</em> 在 <em>str</em> 中第一次出现的索引为0，即以 <code>str.index(prefix) == 0</code> 为判断条件。如果不为0，则去掉 <em>prefix</em> 的最后一位字母继续比较。另外一个要点时，先用strs[0]作为prefix，然后做减量，这个思想在本题中使用很重要。</p>
<pre><code class="language-java">class Solution {
    public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0) {
            return &quot;&quot;;
        }
        String prefix = strs[0];
        if (strs.length == 1) {
            return prefix;
        }
        // 以strs[0]作为前缀，然后查看其他的字符串中是否包含该字符串

        for (int i = 1; i &lt; strs.length; i++) {
            // 该字符串中第一次出现前缀的索引，如果为0，则说明是前缀
            while (strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty()) {
                    return &quot;&quot;;
                }
            }
        }
        return prefix;
    }
}
</code></pre>
<h3 id="爬楼梯">爬楼梯</h3>
<p>可以一步上1个或2个台阶，一共有N个台阶，问有几种走法。显而易见，1级台阶1种，2级台阶两种，3级台阶最后一步可以是走了2级或1级，那么就是1级台阶的走法+2级台阶的走法。同理4级台阶是3级台阶的走法+2级台阶的走法...，很容易想到使用递归的方法解决问题</p>
<pre><code class="language-java">public int climbStairs(int n) {
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }
    return climbStairs(n - 1) + climbStairs(n - 2);
}
</code></pre>
<p>但是这样会做了很多的重复计算，如下图所示<br>
<img src="https://yuncheng1998.github.io/post-images/1618154453666.png" alt="递归树" loading="lazy"><br>
因此最好使用备忘录将每个节点的方法数记录下来，可以申请一个数组dp[]，该数组的填充计算方法为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[n] = dp[n-1]+dp[n-2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
	
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
}
</code></pre>
<p>经过观察可以发现，每次只会使用第n个台阶的前两级的方法数来计算，因此只需申请两个变量即可。每次迭代，step变为a和b的和，同时更新a和b</p>
<pre><code class="language-java">class Solution {
    public int climbStairs(int n) {
        if (n &lt; 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 2;
        }
        int a = 1;
        int b = 2;
        int step = 0;
        // 每一次迭代，step为对应台阶数的步数方法，同时更新a和b
        for (int i = 3; i &lt;= n; i++) {
            step = a + b;
            a = b;
            b = step;
        }
        return step;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Clean Code]]></title>
        <id>https://yuncheng1998.github.io/post/clean-code/</id>
        <link href="https://yuncheng1998.github.io/post/clean-code/">
        </link>
        <updated>2021-04-11T14:29:15.000Z</updated>
        <content type="html"><![CDATA[<p>在一家公司实习，接手了一个权限相关的模块，正处一个新版本上线的时机，这个模块也是从其他模块中拆分出来的，上一任从老代码搬运过来并进行重构，后又由我接手来继续接受重构并进行新权限功能的开发。在重构期间开始读 <em>Robert C. Martin</em> 所著的 <em>代码整洁之道</em> 。在此期间对我起到了很大的指导作用。</p>
<h2 id="方法应该是什么样的">方法应该是什么样的</h2>
<h3 id="短小只做一件事">短小，只做一件事</h3>
<p>方法之所以写的冗长因为它做了太多的事情，一个好的方法应该短小清晰，过于长的代码是难以理解和维护的，因此应尽可能的将长方法进行拆分，首先要理解原方法的含义，然后将它所做的任务拆分成若干子任务，每个子任务进行以面向对象的思想进行封装。并且要规范的命名和写清楚 <em>javadoc</em> 注释。</p>
<h3 id="抽象层级">抽象层级</h3>
<p>这是一个容易被忽视的事情，并不是所有方法都在同一层级上。将方法按抽象层级进行区分并注意调用的位置，适合自顶向下的读代码习惯。</p>
<p>例如要从文件中获得字符串的List，现有一个读取文件的方法 <em>readFile</em> 和一个将字符串转换为字符数组 <em>convertString2List</em> 的方法。</p>
<ol>
<li>两个方法都在 <em>main</em> 中调用</li>
<li><em>main</em> 中调用 <em>readFile</em>，<em>readFile</em> 中调用 <em>convertString2List</em></li>
</ol>
<h3 id="不要返回-null">不要返回 <em>null</em></h3>
<p>低层级的方法尽量避免返回值为 <em>null</em> 的情况发生，来避免高层级代码需要进行的判空处理。应该及时在低层级代码判断null，如果为错误时抛出异常，或者返回空对象</p>
<h3 id="参数">参数</h3>
<p>对于诸如 <em>completeArg</em> 方法，使用 <em>Arg completeArg(Arg arg)</em> 通常要优于使用 <em>void completeArg(Arg arg)</em></p>
<p>对于参数中有 <em>Boolean</em> 类型的方法，若其在做两件不同的事情，应该将其拆分</p>
<p>对于有很多参数的方法，例如 <em>String generateSql(String tableName, String idName, String eiName, String authCondition, String ei)</em> 这样一个生成 <em>SQL</em> 语句的方法，前三个参数作为列名，完全可以用一个单独的类进行封装。若只在本类中调用，可以将其设置为私有类。然后使用对象作为参数<em>String generateSql(SqlArg sqlArg, String authCondition, String ei)</em></p>
<h3 id="无副作用">无副作用</h3>
<p>有些方法具有副作用在于当该方法被调用后，有一些调用者未预见的事情发生了。这主要是是由于命名不规范和违反了只做一件事原则而产生的</p>
<h3 id="不要有输出参数">不要有输出参数</h3>
<p>输出参数是面向过程所遗留下的产物，例如上面所提到的 <em>void completeArg(Arg arg)</em>，这类方法应该被改造为 <em>arg.completeArg()</em>，参数多数自然而染得被看作是输入，输入又输出的参数会给人造成迷惑</p>
<h3 id="分隔指令与询问">分隔指令与询问</h3>
<p>例如 <em>Java</em> 中的 <em>Set</em> 的 <em>add</em> 方法，会返回一个 <em>boolean</em> 类型表示插入是否成功，<em>contains</em> 用来判断集合中是否包含这个值。<em>add</em> 是指令、<em>contains</em> 是询问，应避免使用 <em>add</em> 来替代 <em>contains</em>。当然对于多线程应另行考虑。</p>
<h3 id="异常">异常</h3>
<p>除了模块提供的对外 <em>API</em> ，内部的方法应使用异常而不是错误码。调用的方法并判断返回值是错误码，这本身就违反了分隔指令与询问的原则。当使用 <em>try-catch</em> 去处理异常时，try代码块与catch代码块中分别做了两件不同的事，完全可以将其抽离出作为两个方法。另外对于 <em>try</em> 中有多行代码是容易给人造成混乱的，因为这样不知道异常是由哪些语句抛出的。良好的错误处理的<em>try-catch</em>语句必然是干净整洁的。</p>
<h3 id="结构化编程">结构化编程</h3>
<p><em>Dijkstra</em> 的结构化编程对于较长的方法是有重要作用的，保证这些方法只有一个出口、永远不会有goto语句，可以使这些方法的处理逻辑更加清晰。</p>
<h3 id="如何处理-switch">如何处理 <em>switch</em></h3>
<p>避免 <em>switch</em> 语句使代码违反单一权责原则和开闭原则的最好方法是使用工厂，将 <em>switch</em> 放到抽象工厂内部，用多态来接收返回值。</p>
<h2 id="对象与数据结构">对象与数据结构</h2>
<p>对象和数据结构应该作为两个不同的概念进行区分</p>
<ul>
<li>对象曝露行为，隐藏数据</li>
<li>数据结构曝露数据，没有明显行为</li>
</ul>
<p>通常所写的 <em>DTO</em>、<em>Bean</em> 都是数据结构，开放 <em>get</em>、<em>set</em> 方法可供调用。而 <em>Service</em> 的实现作为对象只去调用曝露的方法而不会关心内部的实现，对于对象我们应该仔细考虑哪些接口适合曝露出来。</p>
<p>对象和数据结构是一个对立的概念，数据结构更适合过程式代码，在不改动既有数据结构的前提下添加方法。而对象适合面向对象的代码，可以在不改动现有方法的情况下添加新的类。</p>
<p><em>The Law of Demeter</em> 是一个检验对象的使用是否标准的好方法。</p>
<blockquote>
<p>类C的的方法f只调用以下对象的方法</p>
<ul>
<li>C</li>
<li>f 创作的对象</li>
<li>作为参数传递给 f 的对象</li>
<li>C 的实体变量持有的对象</li>
</ul>
</blockquote>
<p>Redis 是使用 C语言编写的数据库，内部实现了多种数据结构：动态字符串、字典、压缩表、链表、跳跃表以及整数集合。但又基于数据结构实现了对象系统，每种对象可以根据需要选择不同的数据结构实现，数据结构应该考虑如何有效的存储数据。对象系统则提供交互方法，内部使用指针根据需要选用不同的数据结构。</p>
<h2 id="异常-2">异常</h2>
<h3 id="不可控异常">不可控异常</h3>
<p><em>Java</em> 区分可控异常和运行时异常，可控异常的使用需要在方法签名中对异常进行声明，使用可控异常的底层代码会使所有调用它的方法选择继续上抛还是处理。异常旨在可以在较远处处理错误，抛出的异常打破了代码的封装。例如我们自定义异常时，可以将其自 <em>RuntimeException</em> 类继承，在代码中抛出该异常，然后由 <em>Controller</em> 层一个统一的异常处理器对抛出的异常进行处理。</p>
<h3 id="好的异常捕获">好的异常捕获</h3>
<p>先写 <em>try-catch-finally</em> 语句，自上而下的编程方式容易梳理抽象逻辑，因此先写出异常捕获语句，将其分为三个语句块，这三个语句块分别在做不同的事情，因此可以考虑将其再拆分为方法。</p>
<p>如果一个方法抛出了多个异常，应该如何进行处理？在调用时使用 <em>try-catch</em> 对每个异常进行捕获是丑陋的做法，对于这样的情况，可以使用代理进行解决。为这个方法的对象建立一个代理，在代理类中对抛出多个异常的方法进行包装，在这个包装中进行记录日志等处理，统一抛出一个异常告诉调用者出现了异常。</p>
<p>抛出异常应提供足够的环境说明，而不是简单的只通过堆栈信息来追踪错误信息。使用日志系统来记录操作的初衷，和发生时参数等信息，这些信息被日志系统记录下来有利于错误信息的监控。</p>
<h3 id="特例模式">特例模式</h3>
<p>特例模式同样继承自普通类，但内部封装的是异常处理。诸如某些操作可能返回 <em>null</em>，而这可能作为一种特殊的情况考虑，就可以将其返回 <em>null</em> 的情况修改为返回特例类，有这个特殊对象来处理相应的逻辑，无论如何，null值是不应该被返回和传递的。</p>
<h2 id="类应该是什么样的">类应该是什么样的</h2>
<h3 id="自上而下的原则">自上而下的原则</h3>
<p>类从一组变量列表开始，顺序应为公共静态变量，私有静态变量，私有实体变量。</p>
<p>之后为公共方法，该公共方法调用的私有方法紧跟其后。</p>
<h3 id="单一权责">单一权责</h3>
<p>一个类只应该有一个权责，即只有一条修改的理由。如何判断类是否拥有了过多权责可以用以下方法：</p>
<ol>
<li>是否能明确的为该类命名</li>
<li>类中是否有过多实体变量</li>
</ol>
<p>好的类应该是足够内聚的，将过大的类拆分成内聚的小类，防止过分的耦合。</p>
<h3 id="开闭原则">开闭原则</h3>
<p>好的类要符合开闭原则，对于逻辑复杂的业务，合理的利用设计模式进行类的设计，使系统适应持续性的修改。因此类应该为了适合修改而组织（系统功能级别的修改），新增功能时尽可能少修改现有的类，而是通过扩展系统来添加新的特性。</p>
<h2 id="系统层级的整洁">系统层级的整洁</h2>
<p>系统层级是一个较高的抽象层级，这里主要关注功能实现的框架，而不是一些具体的编码规范。系统应该是整洁的，避免侵害性的架构。</p>
<h3 id="分离构造和使用">分离构造和使用</h3>
<p>分隔系统的构造和使用，让应用程序对构造过程一无所知，只是希望一切拿来即用。起始过程中构造对象会造成复杂的依赖关系，并且我们需要关系在每个环境中是否创建出了正确的对象，这又加大了单元测试的复杂程度，因此需要将构造与使用分开。对象的构造通常我们使用依赖注入或工厂来实现，工厂由应用程序决定何时创建对象，但细节却隔离于应用程序之外。依赖注入是 <em>Spring</em> 注入所提供的一个重要的功能，当我们需要某一对象时，只需要将其注入使用即可，构造过程由 <em>Spring</em> 来提供。</p>
<h3 id="切面">切面</h3>
<p><em>AOP</em> 使得增加新功能时不破坏原有的代码，避免了紧耦合问题。简单的情况下可以使用 Java 代理来实现一个功能在切面层级上的田间，但代理的复杂度和代码量让代码整洁变得很难，并且代理无法在系统范围内指定执行点，因此仍然需要 <em>AOP</em> 框架来实现。</p>
<h3 id="如何处理代码中大量的if-else待补充">如何处理代码中大量的if-else(待补充)</h3>
<ol>
<li>使用Map映射池</li>
<li>使用策略模式</li>
</ol>
]]></content>
    </entry>
</feed>